{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to frads documentation","text":"<p>Version: 2.1.8</p> <p>Frads is an open-source library providing high-level abstraction of Radiance matrix-based simulation workflows.</p> <p>Frads automates setup of these simulations by providing end users with an open-source, high-level abstraction of the Radiance command-line workflow (Unix toolbox model), helping to reduce the steep learning curve and associated user errors. frads also provides the necessary infrastructure needed for seamless integration of Radiance and other modeling tools, such as EnergyPlus.</p>"},{"location":"#intended-audience","title":"Intended audience","text":"<ol> <li>Developers who are interested in incorporating multi-phase matrix methods into their software and are seeking examples and guidance; i.e., LBNL-suggested default parameters and settings; and,</li> <li>Engineering firms, researchers, and students who are comfortable working in the command-line or Python scripting environment and tasked with a project that cannot be completed with existing tools.</li> </ol>"},{"location":"#why-matrix-based-methods","title":"Why matrix-based methods?","text":"<p>Matrix algebraic methods reduce the time needed to perform accurate, ray-tracing based, annual daylight simulations by several orders of magnitude.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation consists of two parts:</p> <ol> <li>How-To Guides: Scenario-based how-to guides</li> <li>Reference: Code API documentation</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>You can find installation instructions on our README.</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>Frads is an open-source library providing high-level abstraction of Radiance matrix-based simulation workflows.</p> <p>Frads automates setup of these simulations by providing end users with an open-source, high-level abstraction of the Radiance command-line workflow (Unix toolbox model), helping to reduce the steep learning curve and associated user errors. frads also provides the necessary infrastructure needed for seamless integration of Radiance and other modeling tools, such as EnergyPlus.</p>"},{"location":"#frads--intended-audience","title":"Intended audience","text":"<ol> <li>Developers who are interested in incorporating multi-phase matrix methods into their software and are seeking examples and guidance; i.e., LBNL-suggested default parameters and settings; and,</li> <li>Engineering firms, researchers, and students who are comfortable working in the command-line or Python scripting environment and tasked with a project that cannot be completed with existing tools.</li> </ol>"},{"location":"#frads--why-matrix-based-methods","title":"Why matrix-based methods?","text":"<p>Matrix algebraic methods reduce the time needed to perform accurate, ray-tracing based, annual daylight simulations by several orders of magnitude.</p>"},{"location":"#frads--why-frads","title":"Why frads?","text":"<p>A good deal of expertise is needed to set up the simulations properly to achieve the desired level of accuracy. frads provides users with tools (e.g., <code>mrad</code>) that automatically determine which matrix-based method to use then sets the associated simulation parameters, helping beginners learn the different matrix methods by observing the tools\u2019 behavior. The user is still required to understand basic concepts underlying matrix-based simulation methods (see tutorials).</p> <p>Matrix-based methods also enable accurate, ray-tracing generated, irradiance, illuminance, and luminance data to be available for run-time data exchange and co-simulations. frads provides users with tools that generate the appropriate Radiance-generated data then interfaces with the \u201cactuator\u201d EMS module in EnergyPlus or within the Spawn-of-EnergyPlus and Modelica co-simulation environment. This enables end users to evaluate the performance of buildings with manual- and automatically-controlled shading and daylighting systems or other site and building features that can change parametrically or on a time-step basis.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This work was supported by the Assistant Secretary for Energy Efficiency and Renewable Energy, Building Technologies Program, of the U.S. Department of Energy, under Contract No. DE-AC02-05CH11231.</p>"},{"location":"install/","title":"Installation","text":"<p>Before you can use frads, you need to install it.</p>"},{"location":"install/#install-python","title":"Install Python","text":"<p>Being a Python based library, you'll need to install Python first. Python version 3.8 or newer is required for frads.</p> <p>Get the latest version of Python at https://www.python.org/downloads/ or with your operating system\u2019s package manager.</p> <p>You can verify that Python is installed by typing python from your cmd/powershell/terminal; you should see something like:</p> <pre><code>$ python\nPython 3.X.X\n[GCC 4.x] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\n</code></pre> <p>After you have Python installed, you should have <code>pip</code> command available in your shell environment as well. You can then use <code>pip</code> to install <code>frads</code>:</p>"},{"location":"install/#install-pyenergyplus","title":"Install pyenergyplus","text":"<p>frads relies on pyenergyplus for running and interacting with EnergyPlus in Python. pyenergyplus (unofficial) can be installed by running</p> <pre><code>$ pip install git+https://github.com/taoning/pyenergyplus_wheels\n</code></pre>"},{"location":"install/#install-frads","title":"Install frads","text":"<p>After you have pyenergyplus installed, you can then use <code>pip</code> to install <code>frads</code>:</p> <pre><code>$ python -m pip install frads\n</code></pre>"},{"location":"install/#verifying","title":"Verifying","text":"<p>To verify that <code>frads</code> can be seen by Python, type <code>python</code> from your shell. Then at the Python prompt, try to import <code>frads</code></p> <pre><code>&gt;&gt;&gt; import frads\n&gt;&gt;&gt; print(frads.__version__)\n1.0.0\n</code></pre>"},{"location":"why/","title":"Why use frads","text":"<p>Matrix algebraic methods reduce the time needed to perform accurate, ray-tracing based, annual daylight simulations by several orders of magnitude. A good deal of expertise is needed to set up the simulations properly to achieve the desired level of accuracy. frads provides users with tools (e.g., <code>mrad</code>) that automatically determine which matrix-based method to use then sets the associated simulation parameters, helping beginners learn the different matrix methods by observing the tools\u2019 behavior. The user is still required to understand basic concepts underlying matrix-based simulation methods (see tutorials).</p> <p>Matrix-based methods also enable accurate, ray-tracing generated, irradiance, illuminance, and luminance data to be available for run-time data exchange and co-simulations. frads provides users with tools that generate the appropriate Radiance-generated data then interfaces with the \u201cactuator\u201d EMS module in EnergyPlus or within the Spawn-of-EnergyPlus and Modelica co-simulation environment. This enables end users to evaluate the performance of buildings with manual- and automatically-controlled shading and daylighting systems or other site and building features that can change parametrically or on a time-step basis.</p>"},{"location":"how-to/","title":"Index","text":""},{"location":"how-to/#radiance","title":"Radiance","text":"<ol> <li> <p>How to setup a simple rtrace workflow?</p> </li> <li> <p>How to setup a workflow configuration?</p> </li> <li> <p>How to calculate workplane illuminance and edgps using three-phase method?</p> </li> <li> <p>How to simulate spatial daylight autonomy using two-phase method?</p> </li> <li> <p>How to simulate annual glare index using five-phase method?</p> </li> <li> <p>How to simulate annual melanopic equivalent daylight illuminance?</p> </li> <li> <p>How to calculate daylight factor?</p> </li> </ol>"},{"location":"how-to/#energyplus","title":"EnergyPlus","text":"<ol> <li> <p>How to run a simple EnergyPlus simulation?</p> </li> <li> <p>How to create a glazing system?</p> </li> <li> <p>How to set up a callback function in EnergyPlus?</p> </li> </ol>"},{"location":"how-to/#radiance-and-energyplus","title":"Radiance and EnergyPlus","text":"<ol> <li> <p>How to enable Radiance in EnergyPlus simulation?</p> </li> <li> <p>How to model dynamic shading control and daylight dimming with EnergyPlus?</p> </li> <li> <p>How to simulate spatial daylight autonomy using three-phase method?</p> </li> </ol>"},{"location":"how-to/guide_ep1/","title":"How to run a simple EnergyPlus simulation?","text":"<p>This guide will show you how to run a simple EnergyPlus simulation. After loading an EnergyPlus model, you can edit the objects and parameters in the model before running the simulation.</p>"},{"location":"how-to/guide_ep1/#0-import-required-python-libraries","title":"0. Import required Python libraries","text":"<p><pre><code>import frads as fr\n</code></pre> Optional: Load reference EnergyPlus model and weather files</p> <p>You will need a working EnergyPlus model in idf or epjson format to initialize an EnergyPlus model. Or you can load an EnergyPlus reference model from <code>pyenergyplus.dataset</code>.</p> <pre><code>from pyenergyplus.dataset import ref_models, weather_files\n</code></pre> <p>Tips: Reference EnergyPlus models and weather files</p> <p>The <code>pyenergyplus.dataset</code> module contains a dictionary of EnergyPlus models and weather files. The keys are the names of the models and weather files. The values are the file paths to the models and weather files.</p> <pre><code>ref_models.keys()\n</code></pre> <p><code>dict_keys([     'full_service_restaurant', 'hospital', 'large_hotel',      'large_office', 'medium_office', 'midrise_apartment',      'outpatient', 'primary_school', 'quick_service_restaurant',     'secondary_school', 'small_hotel', 'small_office',      'standalone_retail', 'strip_mall', 'supermarket', 'warehouse' ])</code></p>"},{"location":"how-to/guide_ep1/#1-initialize-an-energyplus-model","title":"1 Initialize an EnergyPlus model","text":"<p>Initialize an EnergyPlus model by calling <code>load_energyplus_model</code> and passing in a working idf or epjson file path.</p>"},{"location":"how-to/guide_ep1/#11-define-energyplus-model-file-path","title":"1.1 Define EnergyPlus model file path","text":"local filereference model <pre><code>idf = \"medium_office.idf\"\n</code></pre> <pre><code>idf = ref_models[\"medium_office\"] # (1) \n</code></pre> <ol> <li>from pyenergyplus.dataset</li> </ol>"},{"location":"how-to/guide_ep1/#12-load-the-energyplus-model","title":"1.2 Load the EnergyPlus model","text":"<pre><code>epmodel = fr.load_energyplus_model(idf)\n</code></pre>"},{"location":"how-to/guide_ep1/#2-edit-the-energyplus-model-optional","title":"2 Edit the EnergyPlus model (optional)","text":""},{"location":"how-to/guide_ep1/#all-energyplus-objects","title":"All EnergyPlus objects","text":"<p>You can access any EnergyPlus model objects (simulation parameters) as you would do to a class attribute. The EnergyPlus model objects share the same name as that in the Input Data File (IDF) but in lower case separated by underscores. For example, the <code>FenestrationSurface:Detailed</code> object in IDF is <code>fenestration_surface_detailed</code> in <code>EnergyPlusModel</code>.</p> <pre><code>epmodel.fenestration_surface_detailed\n</code></pre> <p><code>{'Perimeter_bot_ZN_1_Wall_South_Window': FenestrationSurfaceDetailed(surface_type=&lt;SurfaceType1.window: 'Window'&gt;, construction_name='Window Non-res Fixed', building_surface_name='Perimeter_bot_ZN_1_Wall_South', outside_boundary_condition_object=None, view_factor_to_ground=&lt;CeilingHeightEnum.autocalculate: 'Autocalculate'&gt;, frame_and_divider_name=None, multiplier=1.0, number_of_vertices=NumberOfVertice2(root=4.0), vertex_1_x_coordinate=1.5, vertex_1_y_coordinate=0.0, vertex_1_z_coordinate=2.3293, vertex_2_x_coordinate=1.5, vertex_2_y_coordinate=0.0, vertex_2_z_coordinate=1.0213, vertex_3_x_coordinate=10.5, vertex_3_y_coordinate=0.0, vertex_3_z_coordinate=1.0213, vertex_4_x_coordinate=10.5, vertex_4_y_coordinate=0.0, vertex_4_z_coordinate=2.3293)}'</code></p> <p>Example: Edit the <code>fenestration_surface_detailed</code> object</p> Change the construction name of the window<pre><code>epmodel.fenestration_surface_detailed[\n    \"Perimeter_bot_ZN_1_Wall_South_Window\"\n].construction_name = \"gs1\"\n</code></pre> <p>Example: Edit the <code>lights</code> object</p> Change the watts per zone floor area<pre><code>epmodel.lights[\"Perimeter_bot_ZN_1_Lights\"].watts_per_zone_floor_area = 10\n</code></pre>"},{"location":"how-to/guide_ep1/#glazing-system-complex-fenestration-system","title":"Glazing system (complex fenestration system)","text":"<p>Use <code>EnergyPlusModel.add_glazing_system()</code> to easily add glazing system (complex fenestration systems) to the <code>construction_complex_fenestration_state</code> object in the EnergyPlus model.</p> <p>First, use the <code>create_glazing_system()</code> function to create a glazing system. Then use <code>EnergyPlusModel.add_glazing_system()</code> to add the glazing system to the EnergyPlus. See How to create a glazing system? for more details.</p> <pre><code>epmodel.add_glazing_system(gs1) # (1) \n</code></pre> <ol> <li><code>gs1 = fr.create_glazing_system(name=\"gs1\", layer_inputs=[fr.LayerInput(\"product1.json\"), fr.LayerInput(\"product2.json\")])</code></li> </ol>"},{"location":"how-to/guide_ep1/#lighting","title":"Lighting","text":"<p>Use <code>EnergyPlusModel.add_lighting()</code> to easily add lighting systems to the <code>lights</code> object in the EnergyPlus model. The function takes in the name of the zone to add lighting, the lighting level in the zone in Watts, and an optional <code>replace</code> argument. If <code>replace</code> is <code>True</code>, the zone's existing lighting system will be replaced by the new lighting system. If <code>replace</code> is <code>False</code> and the zone already has a lighting system, an error will be raised. The default value of <code>replace</code> is <code>False</code>.</p> <pre><code>epmodel.add_lighting(zone=\"Perimeter_bot_ZN_1\", lighting_level=10, replace=True)\n</code></pre>"},{"location":"how-to/guide_ep1/#add-output","title":"Add Output","text":"<p>Use <code>EnergyPlusModel.add_output()</code> to easily add output variables or meters to the <code>Output:Variable</code> or <code>Output:Meter</code> object in the EnergyPlus model. The  method takes in the type of the output (variable or meter), name of the output, and the reporting frequency. The default reporting frequency is <code>Timestamp</code>. </p> <pre><code>epmodel.add_output(\n    output_type=\"variable\",\n    output_name=\"Lights Electricity Rate\",\n    reporting_frequency=\"Hourly\",\n)\n</code></pre> <p>Tip</p> <p>See .rdd file for all available output variables and .mdd file for all available output meters.</p>"},{"location":"how-to/guide_ep1/#3-run-the-energyplus-simulation","title":"3. Run the EnergyPlus simulation","text":"<p>Call <code>EnergyPlusSetup</code> class to set up the EnergyPlus simulation. <code>EnergyPlusSetup</code> takes in the EnergyPlus model and an optional weather file. If no weather file is provided, when calling <code>EnergyPlusSetup.run()</code>, you need to set <code>design_day</code> to <code>True</code> and run design-day-only simulation; otherwise, an error will be raised. Annual simulation requires a weather file.</p>"},{"location":"how-to/guide_ep1/#31-define-weather-file-path-optional","title":"3.1 Define weather file path (optional)","text":"local filereference weather file <pre><code>weather_file = \"USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw\"\n</code></pre> <pre><code>weather_file = weather_files[\"usa_ca_san_francisco\"] # (1) \n</code></pre> <ol> <li>from pyenergyplus.dataset</li> </ol>"},{"location":"how-to/guide_ep1/#32-initialize-energyplus-simulation-setup","title":"3.2 Initialize EnergyPlus simulation setup","text":"<pre><code>epsetup = fr.EnergyPlusSetup(epmodel, weather_file)\n</code></pre>"},{"location":"how-to/guide_ep1/#33-run-the-energyplus-simulation","title":"3.3 Run the EnergyPlus simulation","text":"<p>Call <code>EnergyPlusSetup.run()</code> to run the EnergyPlus simulation. This will generate EnergyPlus output files in the working directory. </p> <p>The function has the following arguments:</p> <ul> <li>output_directory: Output directory path. (default: current directory)</li> <li>output_prefix: Prefix for output files. (default: eplus)</li> <li>output_suffix: Suffix style for output files. (default: L)</li> <li>L: Legacy (e.g., eplustbl.csv)</li> <li>C: Capital (e.g., eplusTable.csv)</li> <li>D: Dash (e.g., eplus-table.csv)</li> <li>silent: If True, do not print EnergyPlus output to console. (default: False)</li> <li>annual: If True, force run annual simulation. (default: False)</li> <li>design_day: If True, force run design-day-only simulation. (default: False)</li> </ul> simpleannualdesign day <pre><code>epsetup.run()\n</code></pre> <pre><code># need a weather file\nepsetup.run(annual=True)\n</code></pre> <pre><code># need to set up design day parameters in EnergyPlus model.\nepsetup.run(design_day=True)\n</code></pre>"},{"location":"how-to/guide_ep2/","title":"How to create a glazing system?","text":"<p>This guide will show you how to create a glazing system (complex fenestration system) using the <code>create_glazing_system()</code> function. The glazing system can be added to the EnergyPlus model's <code>construction_complex_fenestration_state</code> object. See How to run a simple EnergyPlus simulation? for more details.</p> <p>The <code>GlazingSystem</code> class contains information about the glazing system's solar absorptance, solar and visible transmittance and reflectance, and etc. The solar and photopic results are calcuated using pyWincalc.</p> <p>Call <code>create_glazing_system()</code> to create a glazing system. The function takes in the name of the glazing system, a list of <code>LayerInput</code> objects, and an optional list of <code>Gap</code> objects. The function returns a <code>GlazingSystem</code> instance.</p>"},{"location":"how-to/guide_ep2/#layerinput-object","title":"LayerInput Object","text":"<p>The <code>LayerInput</code> class is used to define each layer in a glazing system. It allows you to specify:</p> <ul> <li><code>input_source</code>: Path to the glazing/shading product file (JSON or XML format), or bytes data</li> <li><code>flipped</code>: Boolean to flip the layer orientation (default: False)</li> <li><code>slat_angle_deg</code>: Slat angle in degrees for venetian blinds (default: 0.0)</li> <li><code>openings</code>: OpeningDefinitions object to define the top, bottom, left,right, and front openings of the layer (default: top:0, bottom:0, left:0, right:0, and front:0.05)</li> </ul> <p>The glazing and shading product files can be downloaded from the IGSDB website. The downloaded glazing product files are in JSON format and the shading product files are in XML format. The product files contain information about the product's transmittance, reflectance, and etc.</p> <p>Note</p> <p>The list of <code>LayerInput</code> objects should be in order from exterior to interior.</p> <p>Note</p> <p>The glazing system created by using <code>create_glazing_system()</code> has a default air gap at 0.0127 m thickness if no gaps are specified.</p>"},{"location":"how-to/guide_ep2/#import-the-required-classes-and-functions","title":"Import the required classes and functions","text":"<pre><code>import frads as fr\n</code></pre>"},{"location":"how-to/guide_ep2/#example-1-two-layers-of-glazing-products-with-default-gap","title":"Example 1 Two layers of glazing products with default gap","text":"<p>Double clear glazing system</p> <p>The glazing system consists of the following:</p> <ul> <li>1 layer of clear glass</li> <li>Gap: default air gap at 0.0127 m thickness</li> <li>1 layer of clear glass</li> </ul> <pre><code>gs = fr.create_glazing_system(\n    name=\"double_clear\",\n    layer_inputs=[\n        fr.LayerInput(\"igsdb_product_364.json\"), # clear glass\n        fr.LayerInput(\"igsdb_product_364.json\"), # clear glass\n    ],\n)\n</code></pre>"},{"location":"how-to/guide_ep2/#example-2-two-layers-of-glazing-products-with-custom-gap","title":"Example 2 Two layers of glazing products with custom gap","text":"<p>The <code>gaps</code> argument takes in a list of <code>Gap</code> objects. Each <code>Gap</code> object consists of a list of <code>Gas</code> objects and a float defining the gap thickness. The <code>Gas</code> object consists of the gas type and the gas fraction. The gas fraction is a float between 0 and 1. The sum of all gas fractions should be 1.</p> <p>Electrochromic glazing system</p> <p>The glazing system consists of the following:</p> <ul> <li>1 layer of electrochromic glass</li> <li>1 gap (10% air and 90% argon) at 0.0127 m thickness</li> <li>1 layer of clear glass</li> </ul> <pre><code>gs = fr.create_glazing_system(\n    name=\"ec\",\n    layer_inputs=[\n        fr.LayerInput(\"igsdb_product_7405.json\"), # electrochromic glass\n        fr.LayerInput(\"igsdb_product_364.json\"), # clear glass\n    ], # (1)\n    gaps=[\n        fr.Gap(\n            gas=[fr.Gas(\"air\", 0.1), fr.Gas(\"argon\", 0.9)],\n            thickness_m=0.0127\n        )\n    ],\n)\n</code></pre> <ol> <li>The list of <code>LayerInput</code> objects should be in order from exterior to interior.</li> </ol>"},{"location":"how-to/guide_ep2/#example-3-glazing-with-fabric-shade","title":"Example 3 Glazing with fabric shade","text":"<p>Double glazing with exterior fabric shade</p> <p>The glazing system consists of the following:</p> <ul> <li>1 layer of fabric shade (exterior)</li> <li>Gap: default air gap at 0.0127 m thickness</li> <li>1 layer of clear glass</li> <li>Gap: default air gap at 0.0127 m thickness</li> <li>1 layer of clear glass</li> </ul> <pre><code>gs = fr.create_glazing_system(\n    name=\"double_clear_fabric\",\n    layer_inputs=[\n        fr.LayerInput(\"fabric_shade.xml\"), # fabric shade\n        fr.LayerInput(\"igsdb_product_364.json\"), # clear glass\n        fr.LayerInput(\"igsdb_product_364.json\"), # clear glass\n    ],\n)\n</code></pre>"},{"location":"how-to/guide_ep2/#example-4-glazing-with-venetian-blinds","title":"Example 4 Glazing with venetian blinds","text":"<p>Double glazing with interior venetian blinds at 45-degree slat angle</p> <p>The glazing system consists of the following:</p> <ul> <li>1 layer of clear glass</li> <li>Gap: default air gap at 0.0127 m thickness</li> <li>1 layer of clear glass</li> <li>Gap: default air gap at 0.0127 m thickness</li> <li>1 layer of venetian blinds at 45-degree slat angle</li> </ul> <pre><code>gs = fr.create_glazing_system(\n    name=\"double_clear_blinds\",\n    layer_inputs=[\n        fr.LayerInput(\"igsdb_product_364.json\"), # clear glass\n        fr.LayerInput(\"igsdb_product_364.json\"), # clear glass\n        fr.LayerInput(\"venetian_blinds.json\", slat_angle_deg=45), # venetian blinds\n    ],\n)\n</code></pre> <p>Note</p> <p>The <code>slat_angle_deg</code> parameter allows you to specify the slat angle for venetian blinds. The angle is measured from the horizontal plane at 0 degree. Positive slate angle means the slats are downward towards outside.</p>"},{"location":"how-to/guide_ep2/#example-5-fabric-shade-with-openings","title":"Example 5 Fabric shade with openings","text":"<p>Double glazing with fabric shade that has openings on all sides</p> <p>The glazing system consists of the following:</p> <ul> <li>1 layer of clear glass</li> <li>Gap: default air gap at 0.0127 m thickness</li> <li>1 layer of clear glass</li> <li>Gap: default air gap at 0.0127 m thickness</li> <li>1 layer of fabric shade with openings</li> </ul> <pre><code># Define openings for the shade layer\nopenings = fr.OpeningDefinitions(\n    left_m=0.01,      # 10 mm opening on left side\n    right_m=0.005,    # 5 mm opening on right side\n    top_m=0.0025,     # 2.5 mm opening on top\n    bottom_m=0.005,   # 5 mm opening on bottom\n    front_multiplier=0.05  # 5% opening on front surface\n)\n\ngs = fr.create_glazing_system(\n    name=\"double_clear_shade_openings\",\n    layer_inputs=[\n        fr.LayerInput(\"igsdb_product_364.json\"), # clear glass\n        fr.LayerInput(\"igsdb_product_364.json\"), # clear glass\n        fr.LayerInput(\"fabric_shade.xml\", openings=openings), # fabric with openings\n    ],\n)\n</code></pre> <p>Note</p> <p>The <code>OpeningDefinitions</code> object allows you to specify openings around the perimeter of shading layers. The opening dimensions are in meters. The <code>front_multiplier</code> specifies the fraction of the front surface that is open (0.0 to 1.0).</p>"},{"location":"how-to/guide_ep3/","title":"How to set up a callback function in EnergyPlus?","text":"<p>This guide will show you how to use the callback function to modify the EnergyPlus model during the simulation. </p> <p>The demonstration will use the callback function to change the cooling setpoint temperature based on time of the day or occupancy count at the beginning of each time step during runtime.</p> <p>The callback function is a Python function that can only takes in <code>state</code> as the argument. The callback function is where you define the control logic. </p> <p>Use <code>EnergyPlusModel.set_callback()</code> to set up a callback function. The function takes in the calling point and the callback function. The callback function is called at each time step at the calling point. See Application Guide for EMS for details about the various calling points. </p>"},{"location":"how-to/guide_ep3/#0-import-required-python-libraries","title":"0. Import required Python libraries","text":"<pre><code>import frads as fr\nfrom pyenergyplus.dataset import ref_models, weather_files\n</code></pre>"},{"location":"how-to/guide_ep3/#1-initialize-an-energyplus-model","title":"1. Initialize an EnergyPlus model","text":"<p>You will need a working EnergyPlus model in idf or epjson format to initialize an EnergyPlus model. Or you can load an EnergyPlus reference model from <code>pyenergyplus.dataset</code>. See How to run a simple EnergyPlus simulation? for more information on how to setup an EnergyPlus model.</p> <pre><code>epmodel = fr.load_energyplus_model(ref_models[\"medium_office\"]) # (1)\n</code></pre> <ol> <li>EnergyPlus medium size office reference model from <code>pyenergyplus.dataset</code>.</li> </ol>"},{"location":"how-to/guide_ep3/#2-initialize-energyplus-simulation-setup","title":"2. Initialize EnergyPlus Simulation Setup","text":"<p>Initialize EnergyPlus simulation setup by calling <code>EnergyPlusSetup</code> and passing in an EnergyPlus model and an optional weather file.</p> <pre><code>epsetup = fr.EnergyPlusSetup(\n    epmodel, weather_files[\"usa_ca_san_francisco\"], enable_radiance=True\n) # (1)\n</code></pre> <ol> <li>San Francisco, CA weather file from <code>pyenergyplus.dataset</code>.</li> </ol>"},{"location":"how-to/guide_ep3/#3-define-the-callback-function","title":"3. Define the callback function","text":"<p>Before going into the control logic defined in the callback function, you need to first check if the api is ready at the beginning of each time step.</p> <pre><code>def controller(state):\n# check if the api is fully ready\n    if not epsetup.api.exchange.api_data_fully_ready(state):\n        return\n</code></pre>"},{"location":"how-to/guide_ep3/#update-energyplus-model","title":"Update EnergyPlus model","text":"<p>Use <code>EnergyPlusSetup.actuate</code> to set or update the operating value of an actuator in the EnergyPlus model. <code>EnergyPlusSetup.actuate</code> takes in a component type, name, key, and value. The component type is the actuator category, e.g. \"Weather Data\". The name is the name of the actuator, e.g. \"Outdoor Dew Point\". The key is the instance of the variable to retrieve, e.g. \"Environment\". The value is the value to set the actuator to.</p> <p>Tip</p> <p>Use <code>EnergyPlusSetup.actuators</code> to get a list of actuators in the EnergyPlus model. [component type, name, key]</p> <p>There are also built-in actuator in frads that allows easier actuation of common actuators. See Built-in Actuators for more details.</p> <ul> <li><code>EnergyPlusSetup.actuate_cfs_state</code></li> <li><code>EnergyPlusSetup.actuate_heating_setpoint</code></li> <li><code>EnergyPlusSetup.actuate_cooling_setpoint</code></li> <li><code>EnergyPlusSetup.actuate_lighting_power</code></li> </ul> <p>First, get the current time from the EnergyPlus model by using <code>EnergyPlusSetup.get_datetime</code>. If the current time is between 9 am and 5 pm, set the cooling setpoint to 21 degree Celsius. Otherwise, set the cooling setpoint to 24 degree Celsius.</p> EnergyPlusSetup.actuateEnergyPlusSetup.actuate_cooling_setpoint <pre><code>def controller(state):\n    # check if the api is fully ready\n    if not epsetup.api.exchange.api_data_fully_ready(state):\n        return\n    # get the current time\n    datetime = epsetup.get_datetime()\n    if datetime.hour &gt; 9 and datetime.hour &lt; 17:\n        epsetup.actuate(\n        component_type=\"Zone Temperature Control\",\n        name=\"Cooling Setpoint\",\n        key=\"Perimeter_bot_ZN_1\",\n        value=21,\n    )\n    else:\n        epsetup.actuate(\n        component_type=\"Zone Temperature Control\",\n        name=\"Cooling Setpoint\",\n        key=\"Perimeter_bot_ZN_1\",\n        value=24,\n    )\n</code></pre> <pre><code>def controller(state):\n    # check if the api is fully ready\n    if not epsetup.api.exchange.api_data_fully_ready(state):\n        return\n    # get the current time\n    datetime = epsetup.get_datetime()\n    if datetime.hour &gt; 9 and datetime.hour &lt; 17:\n        epsetup.actuate_cooling_setpoint(zone=\"Perimeter_bot_ZN_1\", value=21)\n    else:\n        epsetup.actuate_cooling_setpoint(zone=\"Perimeter_bot_ZN_1\", value=24)\n</code></pre>"},{"location":"how-to/guide_ep3/#access-energyplus-variable","title":"Access EnergyPlus variable","text":"<p>Access EnergyPlus variable during simulation by using <code>EnergyPlusSetup.get_variable_value</code> and passing in a variable name and key.</p> <p>Tip</p> <p>Use <code>EnergyPlusSetup.get_variable_value</code> to access the EnergyPlus variable during the simulation and use the variable as a control input. </p> <p>Use <code>EnergyPlusSetup.get_variable_value</code> to get the current number of occupants in the zone. If the number of occupants is greater than 0, set the cooling setpoint to 21 degree Celsius. Otherwise, set the cooling setpoint to 24 degree Celsius.</p> <pre><code>def controller(state):\n    # check if the api is fully ready\n    if not epsetup.api.exchange.api_data_fully_ready(state):\n        return\n    # get the current number of occupants in the zone\n    num_occupants = epsetup.get_variable_value(\n        variable_name=\"Zone People Occupant Count\",\n        key=\"Perimeter_bot_ZN_1\",\n    )\n    if num_occupants &gt; 0:\n        epsetup.actuate_cooling_setpoint(zone=\"Perimeter_bot_ZN_1\", value=21)\n    else:\n        epsetup.actuate_cooling_setpoint(zone=\"Perimeter_bot_ZN_1\", value=24)\n</code></pre>"},{"location":"how-to/guide_ep3/#4-set-callback","title":"4. Set callback","text":"<p>Use <code>EnergyPlusModel.set_callback()</code> to set up a callback function. The example uses <code>callback_begin_system_timestep_before_predictor</code>.</p> <p>BeginTimestepBeforePredictor</p> <p>The calling point called \u201cBeginTimestepBeforePredictor\u201d occurs near the beginning of each timestep but before the predictor executes. \u201cPredictor\u201d refers to the step in EnergyPlus modeling when the zone loads are calculated. This calling point is useful for controlling components that affect the thermal loads the HVAC systems will then attempt to meet. Programs called from this point might actuate internal gains based on current weather or on the results from the previous timestep. Demand management routines might use this calling point to reduce lighting or process loads, change thermostat settings, etc.</p> <pre><code>epsetup.set_callback(\n    \"callback_begin_system_timestep_before_predictor\",\n    controller\n)\n</code></pre>"},{"location":"how-to/guide_ep3/#5-run-the-energyplus-simulation","title":"5. Run the EnergyPlus simulation","text":"<pre><code>epsetup.run()\n</code></pre>"},{"location":"how-to/guide_rad1/","title":"How to set up a simple rtrace workflow.","text":"<p>Here we go through the process of setting up a simple Radiance model and the workflow of computing irradiance values.</p>"},{"location":"how-to/guide_rad1/#prepare-a-model","title":"Prepare a model","text":"<p>If you already have a Radiance model setup, you can skip this step and follow along using your own.</p> <p>If you don't have a model already we can use <code>gen room</code> to get ourself a simple Radiance model.</p> <p>Let's generate a open-office sized side-lit room with four same-sized windows. The room will be 12 meters wide, 14 meters deep, a floor to floor height of 4 meters, and a ceiling height of 3 meters. Each window is 2.5 meters in width and 1.8 meters in height and has a sill height of 1 meter. Windows are 0.4 meters apart from each other. Finally, we want our facade to have a thickness of 0.1 meters. We'll call this model 'aroom'. The <code>gen room</code> command is:</p> <pre><code>! gen room 12 14 4 3 \\\n    -w 0.4 1 2.5 1.8 \\\n    -w 3.3 1 2.5 1.8 \\\n    -w 6.2 1 2.5 1.8 \\\n    -w 9.1 1 2.5 1.8 \\\n    -t 0.1 -n aroom # (1)\n</code></pre> <ol> <li><code>gen room</code> is a command line function. To run shell commands from inside a IPython syntax (e.g. Jupyter Notebook), start the code with an exclamation mark (!).</li> </ol> <p>Afterwards, we will have a <code>Objects</code> folder in our current working directory with all of our Radiance model inside.</p> <p><pre><code>|____Objects\n| |____window_03_aroom.rad\n| |____wall_aroom.rad\n| |____window_02_aroom.rad\n| |____ceiling_aroom.rad\n| |____window_01_aroom.rad\n| |____materials_aroom.mat\n| |____window_00_aroom.rad\n| |____floor_aroom.rad\n</code></pre> We can quickly visualize our model using <code>objview</code> and make sure it's what we'd expect in terms of layout and geometry. <pre><code>objview Objects/*aroom.mat Objects/*aroom.rad\n</code></pre> And we can see that it is what we'd expect.</p> <p></p>"},{"location":"how-to/guide_rad1/#generate-an-octree-file","title":"Generate an octree file","text":"<p>Now that we have model, we can start to run some actual simulation. Each code block below can be copy and paste into a something like a Jupyter Lab for an interactive workflow.</p> <p>First lets import all the necessary modules. <pre><code>import datetime\nimport pyradiance as pr\nimport frads as fr\n</code></pre></p> <p>Next lets gather our model files. Notice that we have our material files first in the list.</p> <pre><code>fpaths = [\"Objects/materials_aroom.mat\",\n          \"Objects/ceiling_aroom.rad\",\n          \"Objects/wall_aroom.rad\",\n          \"Objects/floor_aroom.rad\",\n          \"Objects/window_00_aroom.rad\",\n          \"Objects/window_01_aroom.rad\",\n          \"Objects/window_02_aroom.rad\",\n          \"Objects/window_03_aroom.rad\",\n]\n</code></pre> <p>Now that we know where all the paths are, we can call <code>oconv</code> to get ourself a <code>octree</code> for ray tracing. We'd like to save our octree as a <code>aroom.oct</code> file.</p> <pre><code>room_octree = \"aroom.oct\"\nwith open(room_octree, 'wb') as f:\n    f.write(pr.oconv(*fpaths))\n</code></pre> <p>Notices that we have a <code>aroom.oct</code>, which only contains the geometry. We need to define our light source, usually some kind of sky model, for rays to trace to. In this example, we will use Perez all-weather sky model. There are also standard CIE skies as alternatives. To do so, we can use <code>gen_perez_sky</code> function to get our sky description and generate a new octree with it.</p> <p>First to get our sky description, we make up a clear sky on 12-21 12:00 with direct normal irradiance of 800 W/m2 and diffuse horizontal irradiance of 100 W/m2. We also need to define our location in terms of latitude, longitude, time-zone, and elevation.</p> <p><pre><code>date_time = datetime.datetime(2024, 12, 21, 12, 0)\nsky_descr = fr.gen_perez_sky(date_time, latitude=37, longitude=122, timezone=120, dirnorm=800, diffhor=100)\n</code></pre> Once we have our sky description, we can combine it with our <code>aroom.oct</code> octree to make a new octree file. Let's call the octree with our sky specific information, 'aroom_37_122_1221_1200.oct'. <pre><code>room_sky_octree = f'aroom_37_122_1221_1200.oct'\nwith open(room_sky_octree, \"wb\") as f:\n    f.write(pr.oconv(stdin=sky_descr, octree=room_octree))\n</code></pre></p>"},{"location":"how-to/guide_rad1/#get-rays","title":"Get rays","text":"<p>We need send rays to the octree file we just created. In Radiance, rays are made of two vectors, one for the starting position and one for the direction the ray is heading. Essentially, we need six values to define our two vectors in cartesian corrdiantes. A ray positioned at x=0, y=0, z=0, pointing upwards is thus: <pre><code>0 0 0 0 0 1\n</code></pre> For this example, we're gonna simulate workplane illuminance. These are essentially virtual sensor positioned at table height pointing upwards, measuring how much light arrives at your table. To get a grid of such sensors, we can use <code>gen_grid</code> utility function, which need a <code>polygon</code>, <code>spacing</code>, and <code>height</code> as arguments. Spacing and height define the grid spacing and the distance from the polygon from which the grid is based-one. Since we are generating a grid of workplane sensors, we can use our floor as the polygon. To get our floor polygon, we can simply load in our <code>floor_aroom.rad</code> file and parse the polygon using the <code>parse_polygon</code> function from the <code>parsers</code> module. The code block demonstrates how we generate a grid of sensors with 1 meter spacing and 0.75 meters away from the floor:</p> <pre><code>floor_primitives = fr.unpack_primitives(\"Objects/floor_aroom.rad\")\n# Since we only have one primitive in this file,\n# we'll take the first one to parse.\nfloor_polygon = fr.parse_polygon(floor_primitives[0])\ngrid = fr.gen_grid(floor_polygon, 1, 0.75)\n</code></pre>"},{"location":"how-to/guide_rad1/#lets-trace","title":"Let's trace","text":"<p>Finally, after all these preparation, we are ready to trace some rays. Let's first trace a single ray, and use the one of the grid sensors we had just created.</p> <p><pre><code>aray = \" \".join(map(str, grid[0]))\noption = [\"-I+\", \"-ab\", \"1\", \"-ad\", \"64\", \"-aa\", \"0\", \"-lw\", \"0.01\"]\nresult = pr.rtrace(aray.encode(), room_sky_octree, params=option)\n</code></pre> if we print the <code>result</code>, we will see the following: <pre><code>&gt;&gt;&gt; print(result)\n#?RADIANCE\n...\n\n3.23E+01 1.23E+02 7.80E+01\n</code></pre></p> <p>Next, let's trace all of our grid sensors. Since our grid of sensors are a list of lists of floats, we need to process them a little bit before rtrace can take them.</p> <p><pre><code>rays = \"\\n\".join([\" \".join(map(str, row)) for row in grid])\nresults = pr.rtrace(rays.encode(), room_sky_octree, params=option, header=False)\n</code></pre> And our results, now with the header, is the following: <pre><code>\n</code></pre> After weighting these RGB values to obtain illuminance values, it'd be nice if we can visualize it somehow. One of the most common approach to visualize illuminance values over a grid of sensors is to map these values to a color scale.  There are many ways to achieve. Here we're gonna stay in the Python world and use the popular matplotlib library to visualize our results. favorite</p>"},{"location":"how-to/guide_rad2/","title":"How to set up a workflow configuration for Radiance simulation?","text":"<p>What is a workflow configuration?</p> <p>A workflow configuration is an instance of the <code>WorkflowConfig</code> class. It is used to run a two- or three- or five-Phase method simulation in Radiance.</p> <p>The workflow configuration has two parts:</p> <ol> <li> <p><code>settings</code> </p> <ul> <li>i.e number of parallel processes, epw/wea file, latitude, longitude, matrices sampling parameters, and etc.</li> <li>See the Settings class for more details.</li> </ul> </li> <li> <p><code>model</code></p> <ul> <li>i.e. scene, windows, materials, sensors, and views </li> <li>See the Model class for more details.</li> </ul> </li> </ol> <p>How to set up a workflow configuration?</p> <p>Method 1</p> <p>Create instances of the <code>Settings</code> and <code>Model</code> classes to represent the settings and model parameters. Then, pass the <code>Settings</code> and <code>Model</code> instances into the <code>WorkflowConfig</code> class to generate a workflow configuration.</p> <p>Method 2 </p> <p>Use <code>WorkflowConfig.from_dict()</code> to generate a workflow configuration by passing in a dictionary that contains the settings and model parameters.</p>"},{"location":"how-to/guide_rad2/#0-import-the-required-classes-and-functions","title":"0. Import the required classes and functions","text":"<pre><code>import frads as fr\n</code></pre>"},{"location":"how-to/guide_rad2/#method-1","title":"Method 1","text":""},{"location":"how-to/guide_rad2/#11-create-an-instance-of-settings-class","title":"1.1 Create an instance of <code>Settings</code> class","text":"Create an instance of the Settings class<pre><code>settings = fr.Settings()\n</code></pre> Default setting <p>name The name of the simulation. (default=\"\")</p> <p>num_processors: The number of processors to use for the simulation. (default=1)</p> <p>method: The Radiance method to use for the simulation. **(default=\"3phase\") </p> <p>overwrite: Whether to overwrite existing files. (default=False)</p> <p>save_matrices: Whether to save the matrices generated by the simulation. (default=False)</p> <p>sky_basis: The sky basis to use for the simulation. (default=\"r1\")</p> <p>window_basis: The window basis to use for the simulation. (default=\"kf\")</p> <p>non_coplanar_basis: The non-coplanar basis to use for the simulation. (default=\"kf\")</p> <p>sun_basis: The sun basis to use for the simulation. (default=\"r6\")</p> <p>sun_culling: Whether to cull suns. (default=True)</p> <p>separate_direct: Whether to separate direct and indirect contributions. (default=False)</p> <p>epw_file: The path to the EPW file to use for the simulation. (default=\"\")</p> <p>wea_file: The path to the WEA file to use for the simulation. (default=\"\")</p> <p>start_hour: The start hour for the simulation. (default=8)</p> <p>end_hour: The end hour for the simulation. (default=18)</p> <p>daylight_hours_only: Whether to simulate only daylight hours. (default=True)</p> <p>latitude: The latitude for the simulation. (default=37)</p> <p>longitude: The longitude for the simulation. (default=122)</p> <p>timezone: The timezone for the simulation. (default=120)</p> <p>orientation: sky rotation. (default=0)</p> <p>site_elevation: The elevation for the simulation. (default=100)</p> <p>sensor_sky_matrix: The sky matrix sampling parameters. (default_factory=lambda: [\"-ab\", \"6\", \"-ad\", \"8192\", \"-lw\", \"5e-5\"])</p> <p>view_sky_matrix: View sky matrix sampling parameters. (default_factory=lambda: [\"-ab\", \"6\", \"-ad\", \"8192\", \"-lw\", \"5e-5\"])</p> <p>sensor_sun_matrix: Sensor sun matrix sampling parameters. (Default_factory=lambda: [ \"-ab\", \"1\", \"-ad\", \"256\", \"-lw\", \"1e-3\", \"-dj\", \"0\", \"-st\", \"0\"])</p> <p>view_sun_matrix: View sun matrix sampling parameters.(default_factory=lambda: [\"-ab\", \"1\", \"-ad\", \"256\", \"-lw\", \"1e-3\", \"-dj\", \"0\", \"-st\", \"0\"])</p> <p>sensor_window_matrix: Sensor window matrix sampling parameters. (default_factory=lambda: [\"-ab\", \"5\", \"-ad\", \"8192\", \"-lw\", \"5e-5\"])</p> <p>view_window_matrix: View window matrix sampling parameters. (default_factory=lambda: [\"-ab\", \"5\", \"-ad\", \"8192\", \"-lw\", \"5e-5\"])</p> <p>daylight_matrix: Daylight matrix sampling parameters. (default_factory=lambda: [\"-ab\", \"2\", \"-c\", \"5000\"])</p> Edit default setting parameters<pre><code># Edit the number of parallel processes\nsettings.num_processors = 4\n\n# Provide a wea file\nsettings.wea_file = \"oak.wea\"\n</code></pre>"},{"location":"how-to/guide_rad2/#12-create-an-instance-of-model-class","title":"1.2 Create an instance of <code>Model</code> class","text":"<p>The <code>Model</code> class requires the following parameters:</p> <ul> <li><code>scene</code>: An instance of the <code>SceneConfig</code> class.</li> <li><code>windows</code>: A dictionary of instances of the <code>WindowConfig</code> class.</li> <li><code>materials</code>: An instance of the <code>MaterialConfig</code> class.</li> <li><code>sensors</code>: A dictionary of instances of the <code>SensorConfig</code> class.</li> <li><code>views</code>: A dictionary of instances of the <code>ViewConfig</code> class.</li> </ul>"},{"location":"how-to/guide_rad2/#121-scene","title":"1.2.1 Scene","text":"Create an instance of the SceneConfig class<pre><code>scene = fr.SceneConfig(\n    files=[\n    \"walls.rad\",\n    \"ceiling.rad\",\n    \"floor.rad\",\n    \"ground.rad\",\n    ]\n)\n</code></pre> Scene geometry primitive example <p>walls.rad <pre><code>wall_mat polygon wall_1\n0\n0\n12 \n    0   0   0\n    0   0   3\n    0   3   3\n    0   3   0\n</code></pre></p>"},{"location":"how-to/guide_rad2/#122-windows","title":"1.2.2 Windows","text":"Create an instance of the WindowConfig class<pre><code>window1 = fr.WindowConfig(\n    file=\"window1.rad\", # window geomtry primitive file\n    matrix_name=\"window1_matrix\" # specified in materials \n)\n</code></pre> Window geometry primitive example <p>window1.rad <pre><code>window_mat polygon window1\n0\n0\n12 \n    0   1   1\n    0   1   2\n    0   2   2\n    0   2   1\n</code></pre></p>"},{"location":"how-to/guide_rad2/#123-materials","title":"1.2.3 Materials","text":"Create an instance of the MaterialConfig class<pre><code>materials = fr.MaterialConfig(\n    files=[\"materials.mat\"], # material primitive file\n    matrices={\n        \"window1_matrix\": {\"matrix_file\": \"window1_bsdf.xml\"}\n        } # window matrix file\n)\n</code></pre> Materials primitive example <p>materials.mat <pre><code>void plastic wall_mat\n0\n0\n5 0.5 0.5 0.5 0 0\n</code></pre></p>"},{"location":"how-to/guide_rad2/#124-sensors","title":"1.2.4 Sensors","text":"Create an instance of the SensorConfig class<pre><code>sensor1 = fr.SensorConfig(file=\"grid.txt\") # a file of sensor points\n\nsensor_view1 = fr.SensorConfig(\n    data=[[1, 1, 1, 0, -1, 0]]\n) # a sensor point at (1, 1, 1) with a view direction of (0, -1, 0)\n</code></pre> Sensor points example <p>grid.txt</p> <p>x_viewpoint y_viewpoint z_viewpoint x_direction y_direction z_direction <pre><code>0 1 1 0 -1 0\n0 1 2 0 -1 0\n</code></pre></p>"},{"location":"how-to/guide_rad2/#125-views","title":"1.2.5 Views","text":"<pre><code>view1 = fr.ViewConfig(file = \"view1.vf\")\n</code></pre> View example <p>view1.vf</p> <p>view_type view_point view_direction view_up_direction view_horizontal_field_of_view view_vertical_field_of_view view_rotation_angle <pre><code>-vta -vp 1 1 1 -vd 0 -1 0 -vu 0 0 1 -vh 180 -vv 180\n</code></pre></p>"},{"location":"how-to/guide_rad2/#126-create-an-instance-of-the-model-class","title":"1.2.6 Create an instance of the <code>Model</code> class","text":"<p>Tip</p> <ul> <li>All phases require <code>materials</code></li> <li>All phases require <code>sensors</code> or <code>views</code></li> <li>Three- and Five-Phase methods require <code>windows</code></li> <li>If a window matrix name is specified in <code>windows</code>, the corresponding window matrix file must be specified in <code>materials</code></li> <li>There is a corresponding <code>sensors</code> point for each <code>views</code> point. This <code>sensors</code> point could be automatically generally when <code>views</code> is specified in <code>Model</code> or manually defined by the user as shown below. <code>view1</code> in sensors must have the same view direction and view position as <code>view1</code> in views; otherwise, an error will be raised.</li> </ul> <pre><code>model = fr.Model(\n    scene=scene,\n    windows={\"window1\": window1},\n    materials=materials,\n    sensors={\"sensor1\": sensor1, \"view1\": sensor_view1}, # view1 is a sensor point corresponding to view1 in views\n    views={\"view1\": view1}\n)\n</code></pre>"},{"location":"how-to/guide_rad2/#13-pass-settings-and-model-instances-into-workflowconfig-class","title":"1.3 Pass <code>Settings</code> and <code>Model</code> instances into <code>WorkflowConfig</code> class","text":"<pre><code>cfg = fr.WorkflowConfig(settings, model)\n</code></pre>"},{"location":"how-to/guide_rad2/#method-2","title":"Method 2","text":""},{"location":"how-to/guide_rad2/#2-pass-a-dictionary-into-the-workflowconfigfrom_dict-method","title":"2. Pass a dictionary into the <code>WorkflowConfig.from_dict()</code> method","text":"<p>The dictionary should contain the settings and model parameters.</p> dictionary example <pre><code>dict1 = {\n    \"settings\": {\n        \"method\": \"3phase\",\n        \"sky_basis\": \"r1\",\n        \"epw_file\": \"\",\n        \"wea_file\": \"oak.wea\",\n        \"sensor_sky_matrix\": [\"-ab\", \"0\"],\n        \"view_sky_matrix\": [\"-ab\", \"0\"],\n        \"sensor_window_matrix\": [\"-ab\", \"0\"],\n        \"view_window_matrix\": [\"-ab\", \"0\"],\n        \"daylight_matrix\": [\"-ab\", \"0\"],\n    },\n    \"model\": {\n        \"scene\": {\n            \"files\": [\"walls.rad\", \"ceiling.rad\", \"floor.rad\", \"ground.rad\"]\n        },\n        \"windows\": {\n            \"window1\": {\n                \"file\": \"window1.rad\",\n                \"matrix_name\": \"window1_matrix\",\n            }\n        },\n        \"materials\": {\n            \"files\": [\"materials.mat\"],\n            \"matrices\": {\"window1_matrix\": {\"matrix_file\": \"window1_bsdf.xml\"}},\n        },\n        \"sensors\": {\n            \"sensor1\": {\"file\": \"sensor1.txt\"},\n            \"view1\": {\"data\": [[1, 1, 1, 0, -1, 0]]},\n        },\n        \"views\": {\"view1\": {\"file\": \"view1.vf\"}},\n    },\n}\n</code></pre> <pre><code>cfg = fr.WorkflowConfig.from_dict(dict1)\n</code></pre> <p>Use an EnergyPlus model to set up a workflow configuration</p> <p>You can use the <code>epjson_to_rad()</code> function to convert an EnergyPlus model to a Radiance model. The function returns a dictionary of the Radiance model for each exterior zone in the EnergyPlus model. You can use the dictionary to set up the workflow configuration.</p> <pre><code>epmodel = fr.EnergyPlusModel(\"file.idf\") # EnergyPlus model\nradmodel = fr.epjson_to_rad(epmodel) # Radiance model\ndict_zone1 = radmodel[\"zone1\"] # Dictionary of zone1\n</code></pre> <pre><code>cfg = fr.WorkflowConfig.from_dict(dict_zone1)\n</code></pre>"},{"location":"how-to/guide_rad3/","title":"How to calculate workplane illuminance and edgps using three-phase method?","text":"<p>This guide will show you how to calculate workplane illuminance and eDGPs (enhanced simplified Daylight Glare Probability) using the Three-Phase method in Radiance.</p> <p>What is the Three-Phase method?</p> <p>The Three-Phase method a way to perform annual daylight simulation of complex fenestration systems. The method divide flux transfer into three phases or matrices:</p> <ul> <li>V(iew): flux transferred from simulated space to the interior of the fenestration</li> <li>T(ransmission): flux transferred through the fenestration (usually represented by a BSDF)</li> <li>D(aylight): flux transferred from the exterior of fenestration to the sky</li> </ul> <p>Multiplication of the three matrices with the sky matrix gives the illuminance at the simulated point. In the case where one wants to calculate the illuminance for different fenestration systems, one only needs to calculate the daylight and view matrice once and then multiply them with the transmission matrix of each fenestration system.</p> <p>Workflow for setting up a three-phase method</p> <ol> <li> <p>Initialize a ThreePhaseMethod instance with a workflow configuration.</p> </li> <li> <p>(Optional) Save the matrices to file. </p> </li> <li> <p>Generate matrices.</p> </li> <li> <p>Calculate workplane illuminance and eDGPs.</p> </li> </ol>"},{"location":"how-to/guide_rad3/#0-import-the-required-classes-and-functions","title":"0. Import the required classes and functions","text":"<pre><code>from datetime import datetime\nimport frads as fr\n</code></pre>"},{"location":"how-to/guide_rad3/#1-initialize-a-threephasemethod-instance-with-a-workflow-configuration","title":"1. Initialize a ThreePhaseMethod instance with a workflow configuration","text":"<p>To set up a Three-Phase method workflow, call the <code>ThreePhaseMethod</code> class and pass in a workflow configuration that contains information about the settings and model. See How to set up a workflow configuration? for more information.</p> cfg <pre><code>dict1 = {\n    \"settings\": {\n        \"method\": \"3phase\",\n        \"sky_basis\": \"r1\",\n        \"epw_file\": \"\",\n        \"wea_file\": \"oak.wea\",\n        \"sensor_sky_matrix\": [\"-ab\", \"0\"],\n        \"view_sky_matrix\": [\"-ab\", \"0\"],\n        \"sensor_window_matrix\": [\"-ab\", \"0\"],\n        \"view_window_matrix\": [\"-ab\", \"0\"],\n        \"daylight_matrix\": [\"-ab\", \"0\"],\n    },\n    \"model\": {\n        \"scene\": {\n            \"files\": [\"walls.rad\", \"ceiling.rad\", \"floor.rad\", \"ground.rad\"]\n        },\n        \"windows\": {\n            \"window1\": {\n                \"file\": \"window1.rad\",\n                \"matrix_name\": \"window1_matrix\",\n            }\n        },\n        \"materials\": {\n            \"files\": [\"materials.mat\"],\n            \"matrices\": {\"window1_matrix\": {\"matrix_file\": \"window1_bsdf.xml\"}},\n        },\n        \"sensors\": {\n            \"sensor1\": {\"file\": \"sensor1.txt\"},\n            \"view1\": {\"data\": [[1, 1, 1, 0, -1, 0]]},\n        },\n        \"views\": {\"view1\": {\"file\": \"view1.vf\"}},\n    },\n}\n</code></pre> <pre><code>cfg = fr.WorkflowConfig.from_dict(dict1)\n</code></pre> <pre><code>workflow = fr.ThreePhaseMethod(cfg) \n</code></pre>"},{"location":"how-to/guide_rad3/#2-optional-save-the-matrices-to-file","title":"2. (Optional) Save the matrices to file","text":"<p>A *.npz file will be generated in the current working directory. The file name is a hash string of the configuration content.</p> <pre><code>workflow.config.settings.save_matrices = True # default=False\n</code></pre>"},{"location":"how-to/guide_rad3/#3-generate-matrices","title":"3. Generate matrices","text":"<p>Use the <code>generate_matrices()</code> method to generate the following matrices:</p> <ul> <li>View --&gt; window</li> <li>Sensor --&gt; window</li> <li>Daylight</li> </ul> <pre><code>workflow.generate_matrices()\n</code></pre> <p>get workflow from EnergyPlusSetup</p> <p>If you are using the ThreePhaseMethod class in EnergyPlusSetup, you can get the workflow from the EnergyPlusSetup instance. See How to enable Radiance in EnergyPlus simulation? for more information.</p> <pre><code>eps = fr.EnergyPlusSetup(epmodel, weather_file, enable_radiance=True)\nworkflow = eps.rworkflows[zone_name]\n</code></pre>"},{"location":"how-to/guide_rad3/#4-calculate","title":"4. Calculate","text":""},{"location":"how-to/guide_rad3/#41-workplane-illuminance","title":"4.1 workplane illuminance","text":"<p>Use the <code>calculate_sensor()</code> method to calculate workplane illuminance for a sensor. Need to pass in the name of the sensor, a dictionary of window names and their corresponding BSDF matrix file names, datetime, direct normal irradiance (DNI), and diffuse horizontal irradiance (DHI).</p> <pre><code>workflow.calculate_sensor(\n    sensor=\"sensor1\",\n    bsdf={\"window1\": \"window1_matrix\"},\n    time=datetime(2023, 1, 1, 12),\n    dni=800,\n    dhi=100,\n)\n</code></pre> <p>what does calculate_sensor() do behind the scene?</p> <p>It multiplies the view, transmission, daylight, and sky matrices with weights in the red, green, and blue channels to get the illuminance at the sensor point.</p>"},{"location":"how-to/guide_rad3/#42-edgps","title":"4.2 eDGPs","text":"<p>What is eDGPs?</p> <p>eDGPs is an enhanced version of the simplified Daylight Glare Probability (DGPs) to evaluate the glare potential.</p> <p>Use the <code>calculate_edgps()</code> method to calculate eDGPs for a view. Need to pass in the name of the view, a dictionary of window names and their corresponding BSDF matrix file names, datetime, direct normal irradiance (DNI), diffuse horizontal irradiance (DHI), and ambient bounce.</p> <p>Note</p> <p>To calculate eDGPs for view1, you need to specify a view1 key name in <code>dict1[\"model\"][\"views\"]</code> and <code>dict1[\"model\"][\"sensors\"]</code>.</p> <pre><code>workflow.calculate_edgps(\n    view=\"view1\", \n    bsdf={\"window1\": \"window1_matrix\"},\n    time=datetime(2023, 1, 1, 12),\n    dni=800,\n    dhi=100,\n    ambient_bounce=1,\n)\n</code></pre> <p>what does calculate_edgps() do behind the scene?</p> <p>First, use Radiance <code>rpict</code> to render a low-resolution (ambient bouce: 1) high dynamic range image (HDRI). Then, use Radiance <code>evalglare</code> to evaluate the DGP of the HDRI with illuminance modification calculated using the matrix multiplication.</p>"},{"location":"how-to/guide_rad7/","title":"How to calculate daylight factor?","text":"<p>What is daylight factor?</p> <p>Daylight factor (DF) is the ratio of the interior horizontal illuminance to the exterior unobsturcted horizontal illuminance under overcast sky conditions. The higher the daylight factor, the more daylight is available in the room. A minimum daylight factor of 2% is usually recommended for critical visual task zones. </p>"},{"location":"how-to/guide_rad7/#workflow","title":"Workflow","text":"<ol> <li>Build a Radiance model</li> <li>Generate a CIE overcast sky</li> <li>Use raytracing to get the interior horizontal illuminance</li> <li>Compute the daylight factor</li> </ol>"},{"location":"how-to/guide_rad7/#0-import-the-required-classes-and-functions","title":"0. Import the required classes and functions","text":"<pre><code>import datatime\nimport frads as fr\nimport pyradiance as pr\nimport numpy as np\n</code></pre>"},{"location":"how-to/guide_rad7/#1-build-a-radiance-model","title":"1. Build a Radiance model","text":"<p>If you already have a Radiance model setup, please have a octree file storing the scene files and continue on to the next step. If not, follow below to set up a sample Radiance model. See How to setup a simple rtrace workflow? for more details.</p> <p>Use <code>gen room</code> (a command line function) to generate a simple Radiance model. The example 'aroom' is a open-office sized side-lit room with four same-sized windows. The room will be 12 meters wide, 14 meters deep, a floor to floor height of 4 meters, and a ceiling height of 3 meters. Each window is 2.5 meters in width and 1.8 meters in height and has a sill height of 1 meter. Windows are 0.4 meters apart from each other. Finally, the facade has a thickness of 0.1 meters. </p> <pre><code>! gen room 12 14 4 3 \\\n    -w 0.4 1 2.5 1.8 \\\n    -w 3.3 1 2.5 1.8 \\\n    -w 6.2 1 2.5 1.8 \\\n    -w 9.1 1 2.5 1.8 \\\n    -t 0.1 -n aroom # (1)\n</code></pre> <ol> <li><code>gen room</code> is a command line function. To run shell commands from inside a IPython syntax (e.g. Jupyter Notebook), start the code with an exclamation mark (!).</li> </ol> <p>Call <code>pyradiance.oconv</code> to generate a <code>octree</code> file storing the material and geometry files generated from the <code>gen room</code> command in the 'Objects' directory </p> <pre><code>fpaths = [\"Objects/materials_aroom.mat\",\n          \"Objects/ceiling_aroom.rad\",\n          \"Objects/wall_aroom.rad\",\n          \"Objects/floor_aroom.rad\",\n          \"Objects/window_00_aroom.rad\",\n          \"Objects/window_01_aroom.rad\",\n          \"Objects/window_02_aroom.rad\",\n          \"Objects/window_03_aroom.rad\",\n]\n</code></pre> <pre><code>room_octree = \"aroom.oct\"\nwith open(room_octree, 'wb') as f:\n    f.write(pr.oconv(*fpaths))\n</code></pre>"},{"location":"how-to/guide_rad7/#2-generate-a-cie-overcast-sky","title":"2. Generate a CIE overcast sky","text":"<p>Use <code>pyradiance.gensky</code> to generate a CIE overcast sky. The function returns a brightness function (skyfunc) to vary the brightness of the glow material. We will assume the overcast sky has a diffuse horizontal illuminance of 10,000 lux (horizontal diffuse irradiance of 55.866 w/m2).</p> <p><pre><code>dif_hor_illum = 10000\ndif_hor_ird = dif_hor_illum / 179\n</code></pre> <pre><code>sky_func = pr.gensky(\n    dt=datetime.datetime(2024, 12, 21, 12, 0),\n    cloudy=True,\n    horizontal_brightness=dif_hor_ird, # (1)\n    )\n\nprint(sky_func)\n</code></pre></p> <ol> <li>zenith brightness is computed from the horizontal diffuse irradiance (in watts/meter2)</li> </ol> <pre><code>void brightfunc skyfunc\n2 skybr skybright.cal\n0\n3 2 2.286e+01 3.557e+00\n</code></pre> <pre><code>sky_glow = \"skyfunc glow sky_glow 0 0 4 1 1 1 0\".encode()\n\nsky = \"sky_glow source sky 0 0 4 0 0 1 180\".encode()\n\nground = \"sky_glow source ground 0 0 4 0 0 -1 180\".encode()\n</code></pre> <pre><code>sky_scene = sky_func + b'\\n' + sky_glow + b'\\n' + sky + b'\\n' + ground\n</code></pre> add sky scene to octree<pre><code>room_sky_octree = f\"aroom_37_122_1221_1200.oct\"\nwith open(room_sky_octree, \"wb\") as f:\n    f.write(pr.oconv(stdin=sky_descr, octree=room_octree))\n</code></pre>"},{"location":"how-to/guide_rad7/#3-use-raytracing-to-get-the-interior-horizontal-illuminance","title":"3. Use raytracing to get the interior horizontal illuminance","text":"<p>Generate a grid of horizontal workplane sensors for interior horizontal illuminance computation. See How to setup a simple rtrace workflow? for more details.</p> generate grid sensors based on the floor polygon<pre><code>floor_primitives = fr.unpack_primitives(\"Objects/floor_aroom.rad\")\nfloor_polygon = fr.parse_polygon(floor_primitives[0])\ngrid = fr.gen_grid(floor_polygon, 1, 0.75)\n</code></pre> <p>Use <code>pyrandiance.rtrace</code> to compute ray tracing from the sensors. The function returns the irradiance results of all sensors in bytes.</p> <p>rtrace to get irradiance<pre><code>option = [\"-I+\", \"-ab\", \"5\", \"-ad\", \"512\", \"-aa\", \"0\", \"-lw\", \"0.001\"]\nrays = \"\\n\".join([\" \".join(map(str, row)) for row in grid])\nird_results = pr.rtrace(\n    rays.encode(), room_sky_octree, params=option, header=False\n)\nprint(ird_results)\n</code></pre> The sensor data are separeted by '\\n'. </p> <p>Each sensor data has rgb channels irradiance separated by '\\t'</p> <p><code>'4.386912e+00\\t4.386912e+00\\t4.386912e+00\\t\\n2.373928e+00\\t2.373928e+00\\t2.373928e+00\\t ... 0.000000e+00\\t0.000000e+00\\t0.000000e+00\\t\\n'</code></p> reformat the irradiance result<pre><code>rows = ird_results.decode().strip().split(\"\\n\")\ndata = [\n    [float(element) for element in row.split(\"\\t\") if element != \"\"]\n    for row in rows\n]\nird_array = np.array(data)\n</code></pre> <p>Apply coefficients to convert irradiance into illuminance</p> convert irradiance to illuminance<pre><code>illum = ird_array[:, 0] * 47.4 + ird_array[:, 1] * 119.9 + ird_array[:, 2] * 11.6 # (1)\n</code></pre> <ol> <li>red: 47.4, blue: 119.9, green: 11.6</li> </ol>"},{"location":"how-to/guide_rad7/#4-compute-the-daylight-factor","title":"4. Compute the daylight factor","text":"daylight factor = interior illuminance / exterior illuminance * 100<pre><code>df = illum / dif_hor_illum * 100\n</code></pre>"},{"location":"how-to/guide_rad7/#data-visualization","title":"data visualization","text":"import visualization packages<pre><code>import matplotlib.pyplot as plt\n</code></pre> <pre><code>fig, ax = plt.subplots()\nx = [data[0] for data in grid]\ny = [data[1] for data in grid]\n_plot = ax.scatter(\n    x,\n    y,\n    c=df,\n    cmap=\"plasma\",\n    s=15,\n    vmin=0,\n    vmax=max(df),\n    rasterized=True,\n)\nax.set(\n    xlabel=\"x position [m]\",\n    ylabel=\"y position [m]\",\n)\n\nfig.colorbar(_plot, ax=ax, label=\"Daylight Factor [%]\")\nfig.tight_layout()\n</code></pre>"},{"location":"how-to/guide_radep1/","title":"How to enable Radiance in EnergyPlus simulation?","text":"<p>This guide will show you how to enable Radiance in EnergyPlus simulation. </p> <p>Users can enable Radiance for desired accuracy in daylighting simulation. Radiance can be used to calculate workplane illuminance, eDGPs, and etc. See How to calculate workplane illuminance and eDGPs using three-phase method? for more information.</p> <p>Workflow</p> <ol> <li> <p>Setup an EnergyPlus Model</p> </li> <li> <p>Setup EnergyPlus Simulation</p> </li> </ol>"},{"location":"how-to/guide_radep1/#0-import-the-required-classes-and-functions","title":"0. Import the required classes and functions","text":"<pre><code>import frads as fr\n</code></pre>"},{"location":"how-to/guide_radep1/#1-setup-an-energyplus-model","title":"1. Setup an EnergyPlus Model","text":"<p>You will need a working EnergyPlus model in idf or epjson format to initialize an EnergyPlus model. Or you can load an EnergyPlus reference model from <code>pyenergyplus.dataset</code>. See How to run a simple EnergyPlus simulation? for more information on how to setup an EnergyPlus model.</p> <pre><code>epmodel = fr.load_energyplus_model(\"medium_office.idf\")\n</code></pre>"},{"location":"how-to/guide_radep1/#2-setup-energyplus-simulation","title":"2. Setup EnergyPlus Simulation","text":"<p>Initialize EnergyPlus simulation setup by calling <code>EnergyPlusSetup</code> and passing in an EnergyPlus model and an optional weather file.</p> <p>To enable Radiance for daylighting simulation, set <code>enable_radiance</code> to <code>True</code>; default is <code>False</code>. When <code>enable_radiance</code> is set to <code>True</code>, the <code>EnergyPlusSetup</code> class will automatically setup the three-phase method in Radiance. </p> <pre><code>epsetup = fr.EnergyPlusSetup(\n    epmodel, weather_files[\"usa_ca_san_francisco\"], enable_radiance=True\n)\n</code></pre> <p>After the radiance is enabled, the following calculations can be performed:</p> Workplane illuminanceSimplified Daylight Glare Probability (eDGPs) <p><code>epsetup.calculate_wpi()</code> more info</p> <p>or </p> <p><code>epsetup.rworkflows[zone_name].calculate_sensor()</code>more info</p> <p><code>epsetup.calculate_edgps()</code> more info</p> <p>or </p> <p><code>epsetup.rworkflows[zone_name].calculate_edgps()</code>more info</p> <p>See How to calculate workplane illuminance and eDGPs using three-phase method? and How to simulate spatial daylight autonomy using three-phase method? for more information on how to calculate workplane illuminance and eDGPs using Radiance.</p>"},{"location":"how-to/guide_radep2/","title":"How to model dynamic shading control and daylight dimming with EnergyPlus?","text":"<p>This guide will demonstrate how to use a controller function to control the shading state, cooling setpoint temperature, and electric lighting power intensity during simulation. </p> <p>The example is a medium office building with a four tinted states electrochromic glazing system. At the beginning of each timestep, EnergyPlus will call the controller function that operates the facade shading state based on exterior solar irradiance, cooling setpoint temperature based on time of day (pre-cooling), and electric lighting power intensity based on occupancy and workplane illuminance (daylight dimming). The workplane illuminance is calculated using the three-phase method in Radiance.</p> <p>Workflow</p> <ol> <li> <p>Setup an EnergyPlus Model</p> <p>1.1 Initialize an EnergyPlus model</p> <p>1.2 Create glazing systems (Complex Fenestration States)</p> <p>1.3 Add glazing systems to EnergyPlus model</p> <p>1.4 Add lighting systems to EnergyPlus model</p> </li> <li> <p>Setup EnergyPlus Simulation</p> <p>2.1 Initialize EnergyPlus Simulation Setup</p> <p>2.2 Define control algorithms using a controller function</p> <p>2.3 Set callback</p> <p>2.4 Run simulation</p> </li> </ol> <pre><code>graph LR\n    subgraph IGSDB\n    A[Step 1.2 &lt;br/&gt; glazing/shading products];\n    end\n\n    subgraph frads\n\n    C[Step 1.1 idf/epjs] --&gt; |Initialize an EnergyPlus model| E;\n\n    subgraph Step 2 EnergyPlus Simulation Setup\n    subgraph Radiance\n    R[Workplane Illuminance];\n    end\n    subgraph EnergyPlus\n    E[EnergyPlusModel]&lt;--&gt; K[Step 2.2 &amp; 2.3 &lt;br/&gt; controller function];\n    E &lt;--&gt; R;\n    K &lt;--&gt; R;\n    end\n    end\n\n    subgraph  WincalcEngine\n    A --&gt; D[Step 1.3 &lt;br/&gt; create a glazing system &lt;br/&gt; per CFS state];\n    D --&gt; |Add glazing systems| E;\n    end\n\n    L[Step 1.4 lighting systems] --&gt; |Add lighting| E;\n\n    end</code></pre>"},{"location":"how-to/guide_radep2/#0-import-required-python-libraries","title":"0. Import required Python libraries","text":"<pre><code>import frads as fr\nfrom pyenergyplus.dataset import ref_models, weather_files\n</code></pre>"},{"location":"how-to/guide_radep2/#1-setup-an-energyplus-model","title":"1. Setup an EnergyPlus Model","text":""},{"location":"how-to/guide_radep2/#11-initialize-an-energyplus-model","title":"1.1 Initialize an EnergyPlus model","text":"<p>You will need a working EnergyPlus model in idf or epjson format to initialize an EnergyPlus model. Or you can load an EnergyPlus reference model from <code>pyenergyplus.dataset</code>. See How to run a simple EnergyPlus simulation? for more information on how to setup an EnergyPlus model.</p> <pre><code>epmodel = fr.load_energyplus_model(ref_models[\"medium_office\"]) # (1)\n</code></pre> <ol> <li>EnergyPlus medium size office reference model from <code>pyenergyplus.dataset</code>.</li> </ol>"},{"location":"how-to/guide_radep2/#12-create-glazing-systems-complex-fenestration-states","title":"1.2 Create glazing systems (Complex Fenestration States)","text":"<p>Create four glazing systems for the four electrochromic tinted states</p> <p>Each glazing system consists of:</p> <ul> <li>One layer of electrochromic glass</li> <li>One gap (10% air and 90% argon) at 0.0127 m thickness</li> <li>One layer of clear glass</li> </ul> <p>Call <code>create_glazing_system</code> to create a glazing system. See How to create a glazing system? for more details on how to create a glazing system.</p> <pre><code>gs_ec01 = fr.create_glazing_system(\n    name=\"ec01\",\n    layer_inputs=[\n        fr.LayerInput(\"igsdb_product_7405.json\"), # electrochromic glass Tvis: 0.01\n        fr.LayerInput(\"igsdb_product_364.json\"), # clear glass\n    ],\n    gaps=[\n        fr.Gap(\n            gas=[fr.Gas(\"air\", 0.1), fr.Gas(\"argon\", 0.9)], \n            thickness_m=0.0127\n        )\n    ],\n)\n</code></pre> Create glazing systems for the other tinted electrochromic states <pre><code>gs_ec06 = fr.create_glazing_system(\n    name=\"ec06\",\n    layer_inputs=[\n        fr.LayerInput(\"igsdb_product_7407.json\"), \n        fr.LayerInput(\"igsdb_product_364.json\"),\n    ],\n    gaps=[\n        fr.Gap(\n            [fr.Gas(\"air\", 0.1), fr.Gas(\"argon\", 0.9)], 0.0127\n        )\n    ],\n)\n\ngs_ec18 = fr.create_glazing_system(\n    name=\"ec18\",\n    layer_inputs=[\n        fr.LayerInput(\"igsdb_product_7404.json\"),\n        fr.LayerInput(\"igsdb_product_364.json\"),\n    ],\n    gaps=[\n        fr.Gap(\n            [fr.Gas(\"air\", 0.1), fr.Gas(\"argon\", 0.9)], 0.0127\n        )\n    ],\n)\n\ngs_ec60 = fr.create_glazing_system(\n    name=\"ec60\",\n    layer_inputs=[\n        fr.LayerInput(\"igsdb_product_7406.json\"),\n        fr.LayerInput(\"igsdb_product_364.json\"),\n    ],\n    gaps=[\n        fr.Gap(\n            [fr.Gas(\"air\", 0.1), fr.Gas(\"argon\", 0.9)], 0.0127\n        )\n    ],\n)\n</code></pre>"},{"location":"how-to/guide_radep2/#13-add-glazing-systems-to-energyplus-model","title":"1.3 Add glazing systems to EnergyPlus model","text":"<p>Call <code>EnergyPlusModel.add_glazing_system()</code> to add glazing systems to the EnergyPlus model. </p> <pre><code>epmodel.add_glazing_system(gs_ec01)\n</code></pre> Add other glazing systems to the EnergyPlus model <pre><code>epmodel.add_glazing_system(gs_ec06)\nepmodel.add_glazing_system(gs_ec18)\nepmodel.add_glazing_system(gs_ec60)\n</code></pre>"},{"location":"how-to/guide_radep2/#14-add-lighting-systems-to-energyplus-model","title":"1.4 Add lighting systems to EnergyPlus model","text":"<p>Call <code>EnergyPlusModel.add_lighting</code> to add lighting systems to the EnergyPlus model. </p> <pre><code>epmodel.add_lighting(\n    zone=\"Perimeter_bot_ZN_1\",\n    lighting_level=1200, # (1)\n    replace=True\n)\n</code></pre> <ol> <li>1200W is the maximum lighting power density for the zone. This will be dimmed based on the daylight illuminance.</li> </ol>"},{"location":"how-to/guide_radep2/#2-setup-energyplus-simulation","title":"2. Setup EnergyPlus Simulation","text":""},{"location":"how-to/guide_radep2/#21-initialize-energyplus-simulation-setup","title":"2.1 Initialize EnergyPlus Simulation Setup","text":"<p>Initialize EnergyPlus simulation setup by calling <code>EnergyPlusSetup</code> and passing in an EnergyPlus model and an optional weather file. Enable Radiance for daylighting simulation by setting <code>enable_radiance</code> to <code>True</code>. See How to enable Radiance in EnergyPlus simulation? for more information.</p> <pre><code>epsetup = fr.EnergyPlusSetup(\n    epmodel, weather_files[\"usa_ca_san_francisco\"], enable_radiance=True\n) # (1)\n</code></pre> <ol> <li>San Francisco, CA weather file from <code>pyenergyplus.dataset</code>.</li> </ol>"},{"location":"how-to/guide_radep2/#22-define-control-algorithms-using-a-controller-function","title":"2.2 Define control algorithms using a controller function","text":"<p>The controller function defines the control algorithm and control the facade shading state, cooling setpoint temperature, and electric lighting power intensity in the EnergyPlus model during simulation.</p> <p>Controller function</p> <p>The example shows how to implement control algorithms for zone \"Perimeter_bot_ZN_1\", which has a window named \"Perimeter_bot_ZN_1_Wall_South_Window\" and lighting named \"Perimeter_bot_ZN_1\".</p> <ul> <li>Facade CFS state based on exterior solar irradiance</li> <li>Cooling setpoint temperature based on time of day (pre-cooling)</li> <li>Electric lighting power intensity based on occupancy and workplane illuminance (daylight dimming)</li> </ul> <p>The controller function takes in a <code>state</code> argument. See How to set up a callback function in EnergyPlus? for more details on how to define a controller function.</p> <pre><code>def controller(state):\n    # check if the api is fully ready\n    if not epsetup.api.exchange.api_data_fully_ready(state):\n        return\n\n    # control facade shading state based on exterior solar irradiance\n    # get exterior solar irradiance\n    ext_irradiance = epsetup.get_variable_value(\n        name=\"Surface Outside Face Incident Solar Radiation Rate per Area\",\n        key=\"Perimeter_bot_ZN_1_Wall_South_Window\",\n    )\n    # facade shading state control algorithm\n    if ext_irradiance &lt;= 300:\n        ec = \"60\"\n    elif ext_irradiance &lt;= 400 and ext_irradiance &gt; 300:\n        ec = \"18\"\n    elif ext_irradiance &lt;= 450 and ext_irradiance &gt; 400:\n        ec = \"06\"\n    elif ext_irradiance &gt; 450:\n        ec = \"01\"\n    cfs_state = f\"ec{ec}\"\n    # actuate facade shading state\n    epsetup.actuate_cfs_state(\n        window=\"Perimeter_bot_ZN_1_Wall_South_Window\",\n        cfs_state=cfs_state,\n    )\n\n    # control cooling setpoint temperature based on the time of day\n    # pre-cooling\n    # get the current time\n    datetime = epsetup.get_datetime()\n    # cooling setpoint temperature control algorithm\n    if datetime.hour &gt;= 16 and datetime.hour &lt; 21:\n        clg_setpoint = 25.56\n    elif datetime.hour &gt;= 12 and datetime.hour &lt; 16:\n        clg_setpoint = 21.67\n    else:\n        clg_setpoint = 24.44\n    # actuate cooling setpoint temperature\n    epsetup.actuate_cooling_setpoint(\n        zone=\"Perimeter_bot_ZN_1\", value=clg_setpoint\n    )\n\n    # control lighting power based on occupancy and workplane illuminance\n    # daylight dimming\n    # get occupant count and direct and diffuse solar irradiance\n    occupant_count = epsetup.get_variable_value(\n        name=\"Zone People Occupant Count\", key=\"PERIMETER_BOT_ZN_1\"\n    )\n    # calculate average workplane illuminance using Radiance\n    avg_wpi = epsetup.calculate_wpi(\n        zone=\"Perimeter_bot_ZN_1\",\n        cfs_name={\n            \"Perimeter_bot_ZN_1_Wall_South_Window\": cfs_state\n        },\n    ).mean()\n    # electric lighting power control algorithm\n    if occupant_count &gt; 0:\n        lighting_power = (\n            1 - min(avg_wpi / 500, 1)\n        ) * 1200  # 1200W is the nominal lighting power density\n    else:\n        lighting_power = 0\n    # actuate electric lighting power\n    epsetup.actuate_lighting_power(\n        light=\"Perimeter_bot_ZN_1\",\n        value=lighting_power,\n    )\n</code></pre>"},{"location":"how-to/guide_radep2/#23-set-callback","title":"2.3 Set callback","text":"<p>Register the controller functions to be called back by EnergyPlus during runtime by calling <code>set_callback</code>and passing in a callback point and function. See How to set up a callback function in EnergyPlus? for more details.</p> <pre><code>epsetup.set_callback(\n    \"callback_begin_system_timestep_before_predictor\",\n    controller\n)\n</code></pre>"},{"location":"how-to/guide_radep2/#24-run-simulation","title":"2.4 Run simulation","text":"<pre><code>epsetup.run()\n</code></pre>"},{"location":"how-to/guide_radep3/","title":"How to simulate spatial daylight autonomy using three-phase method?","text":"<p>This guide will show you how to calculate spatial daylight autonomy (sDA) using the Three-Phase method in Radiance. This guide shows how to automatically generate a Radiance model and three-phase method workflow from a EnergyPlus model. See How to setup a workflow configuration? and How to calculate workplane illuminance and eDGPs using three-phase method? for more information on how to setup a workflow configuration and calculate workplane illuminance without an EnergyPlus model.</p> <p>What is spatial daylight autonomy?</p> <p>Spatial daylight autonomy (sDA) is the percentage of the area that meets a minimum illuminance threshold for a specified fraction of the annual occupied hours. The target illuminance threshold is usually 300 lux for 50% of the occupied period.</p> <p>Workflow</p> <ol> <li> <p>Import the required classes and functions</p> </li> <li> <p>Setup an EnergyPlus Model</p> <ol> <li>Initialize an EnergyPlus model</li> <li>Create glazing systems (Complex Fenestration States)</li> <li>Add the glazing system to the EnergyPlus model</li> </ol> </li> <li> <p>Setup EnergyPlus Simulation</p> <ol> <li>Initialize EnergyPlus Simulation Setup</li> <li>Calculate workplane illuminance </li> <li>Run the simulation</li> </ol> </li> <li> <p>Calculate sDA</p> </li> <li> <p>Visualize sDA (optional)</p> </li> </ol>"},{"location":"how-to/guide_radep3/#0-import-the-required-classes-and-functions","title":"0. Import the required classes and functions","text":"<pre><code>import datetime\nimport numpy as np\n\nimport frads as fr\nfrom pyenergyplus.dataset import weather_files\n</code></pre>"},{"location":"how-to/guide_radep3/#1-setup-an-energyplus-model","title":"1. Setup an EnergyPlus Model","text":""},{"location":"how-to/guide_radep3/#11-initialize-an-energyplus-model","title":"1.1 Initialize an EnergyPlus model","text":"<p>Initialize an EnergyPlus model by calling <code>load_energyplus_model</code> and passing in an EnergyPlus model in an idf or epjson file format.</p> <pre><code>epmodel = fr.load_energyplus_model(\"RefBldgMediumOfficeNew2004_southzone.idf\")\n</code></pre>"},{"location":"how-to/guide_radep3/#12-create-glazing-systems-complex-fenestration-states","title":"1.2 Create glazing systems (Complex Fenestration States)","text":"<p>Create a glazing system using <code>create_glazing_system()</code> with layer inputs and gaps. Each <code>LayerInput</code> object specifies a glazing or shading (fabric or venetian blinds) material. Gaps between layers are defined with <code>Gap</code> objects containing gas composition and thickness.</p> Create a glazing system<pre><code>gs_ec01 = fr.create_glazing_system(\n    name=\"ec01\",\n    layer_inputs=[\n        fr.LayerInput(\"igsdb_product_7405.json\"),\n        fr.LayerInput(\"CLEAR_3.DAT\"),\n    ],\n    gaps=[\n        fr.Gap(\n            gas=[fr.Gas(\"air\", 0.1), fr.Gas(\"argon\", 0.9)], \n            thickness_m=0.0127\n        )\n    ],\n)\n</code></pre> Add the glazing system to the EnergyPlus model<pre><code>epmodel.add_glazing_system(gs_ec01)\n</code></pre>"},{"location":"how-to/guide_radep3/#2-setup-energyplus-simulation","title":"2. Setup EnergyPlus Simulation","text":""},{"location":"how-to/guide_radep3/#21-initialize-energyplus-simulation-setup","title":"2.1 Initialize EnergyPlus Simulation Setup","text":"<p>Initialize EnergyPlus simulation setup by calling <code>EnergyPlusSetup</code> and passing in an EnergyPlus model and an optional weather file.</p> <p>To enable Radiance for daylighting simulation, set <code>enable_radiance</code> to <code>True</code>. The default value of <code>enable_radiance</code> is <code>False</code>. This step will setup the three-phase method in Radiance. </p> <pre><code>eps = fr.EnergyPlusSetup(\n    epmodel, weather_files[\"usa_ca_san_francisco\"], enable_radiance=True\n)\n</code></pre>"},{"location":"how-to/guide_radep3/#22-calculate-workplane-illuminance","title":"2.2 Calculate workplane illuminance","text":"<p>Use the <code>calculate_wpi()</code> method inside a callback function to calculate the workplane illuminance at each timestamp. Save the workplane illuminance to a variable.</p> <p>Note</p> <p>The <code>calculate_wpi()</code> method calls the <code>ThreePhaseMethod</code> class in the background. See How to calculate workplane illuminance and eDGPs using three-phase method? for more information on how to use the <code>ThreePhaseMethod</code> class directly.</p> Create a list to store the workplane illuminance<pre><code>wpi_list = []\n</code></pre> Define a callback function to calculate the workplane illuminance<pre><code>def callback_func(state):\n    # check if the api is fully ready\n    if not eps.api.exchange.api_data_fully_ready(state):\n        return\n\n    # get the current time\n    datetime = eps.get_datetime()\n    # only calculate workplane illuminance during daylight hours\n    if  datetime.hour &gt;= 8 and datetime.hour &lt; 18:\n        wpi = eps.calculate_wpi(\n            zone=\"Perimeter_bot_ZN_1\",\n            cfs_name={\n                \"Perimeter_bot_ZN_1_Wall_South_Window\": \"ec01\",\n            }, # {window: glazing system}\n        ) # an array of illuminance for all sensors in the zone\n        wpi_list.append(wpi)\n</code></pre>"},{"location":"how-to/guide_radep3/#23-run-the-simulation","title":"2.3 Run the simulation","text":"<p>Set the callback function to <code>set_callback</code> and run the simulation. Refer to Application Guide for EMS for descriptions of the calling points.</p> Set the callback function<pre><code>eps.set_callback(\"callback_begin_system_timestep_before_predictor\", callback)\n</code></pre> Run the simulation<pre><code>eps.run(annual=True) # run annual simulation\n</code></pre>"},{"location":"how-to/guide_radep3/#3-calculate-sda","title":"3. Calculate sDA","text":"<p>Each element in <code>wpi_list</code> is a numpy array of sensors' workplane illuminance at each timestamp. Concatenate the numpy arrays in the <code>wpi_list</code> to a single numpy array. Then calculate the percentage of time when the workplane illuminance is greater than 300 lux.</p> Generate a numpy array of percentage of time when the sensor's workplane illuminance is greater than 300 lux<pre><code>wpi_all = np.concatenate(wpi_list, axis=1)\nlx300 = np.sum(wpi_all &gt;= 300, axis=1) / wpi_all.shape[1] * 100\n</code></pre> Generate a numpy array of x and y coordinates of the sensors<pre><code>xy = np.array(\n    eps.rconfigs[\"Perimeter_bot_ZN_1\"]\n    .model.sensors[\"Perimeter_bot_ZN_1_Floor\"]\n    .data\n)[:, :2]\n</code></pre> Concatenate the lx300 and xy numpy arrays to a single numpy array<pre><code>sda = np.concatenate([xy, lx300.reshape(-1, 1)], axis=1)\n</code></pre>"},{"location":"how-to/guide_radep3/#4-visualize-sda-optional","title":"4. Visualize sDA (optional)","text":"import matplotlib<pre><code>import matplotlib.pyplot as plt\n</code></pre> Plot the sDA<pre><code>fig, ax = plt.subplots(figsize=(4, 3.5))\nx, y, color = sda[:, 0], sda[:, 1], sda[:, 2]\nplot = ax.scatter(\n    x,\n    y,\n    c=color,\n    cmap=\"plasma\",\n    s=15,\n    vmin=0,\n    vmax=100,\n    rasterized=True,\n)\nax.set(\n    xlabel = \"x position [m]\",\n    ylabel = \"y position [m]\",\n)\n\nfig.colorbar(plot, ax=ax, label=\"Daylight Autonomy [%]\")\nfig.tight_layout()\n</code></pre>"},{"location":"how-to/guide_radep4/","title":"How to calculate melanopic illuminance?","text":"<p>This guide will show you how to calculate melanopic illuminance (mev) using the Three-Phase method in Radiance with EnergyPlus integration. The guide demonstrates both photopic illuminance and melanopic illuminance calculations.</p> <p>What is melanopic illuminance ?</p> <p>Melanopic illuminance (mev), also known as melanopic lux, is a measure of light's effectiveness at stimulating the melanopsin-containing intrinsically photosensitive retinal ganglion cells (ipRGCs) in the human eye. These cells are responsible for non-visual responses to light, including:</p> <ul> <li>Circadian rhythm regulation</li> <li>Melatonin suppression</li> <li>Alertness and sleep-wake cycle control</li> <li>Pupillary light reflex</li> </ul> <p>Unlike photopic illuminance, which measures light based on the photopic luminous efficiency function that peaks at 555 nm (green light), melanopic illuminance is weighted towards shorter wavelengths, with peak sensitivity around 490 nm (blue-cyan light). This makes melanopic lux particularly relevant for evaluating lighting conditions for circadian health and alertness in buildings.</p> <p>Workflow</p> <ol> <li> <p>Setup an EnergyPlus Model</p> </li> <li> <p>Create glazing systems with melanopic BSDF</p> </li> <li> <p>Setup EnergyPlus Simulation with Radiance</p> </li> <li> <p>Add melanopic BSDF to the simulation</p> </li> <li> <p>Calculate photopic and melanopic illuminance</p> </li> </ol>"},{"location":"how-to/guide_radep4/#0-import-required-python-libraries","title":"0. Import required Python libraries","text":"<pre><code>import frads as fr\nfrom pyenergyplus.dataset import ref_models, weather_files\nfrom datetime import datetime\n</code></pre>"},{"location":"how-to/guide_radep4/#1-setup-an-energyplus-model","title":"1. Setup an EnergyPlus Model","text":"<p>You will need a working EnergyPlus model in idf or epjson format to initialize an EnergyPlus model. Or you can load an EnergyPlus reference model from <code>pyenergyplus.dataset</code>. See How to run a simple EnergyPlus simulation? for more information on how to setup an EnergyPlus model.</p> <pre><code>epmodel = fr.load_energyplus_model(ref_models[\"medium_office\"])\n</code></pre>"},{"location":"how-to/guide_radep4/#2-create-glazing-systems-with-melanopic-bsdf","title":"2. Create glazing systems with melanopic BSDF","text":"<p>To calculate melanopic illuminance, you need to create glazing systems with melanopic BSDF data by setting <code>mbsdf=True</code> when calling <code>create_glazing_system()</code>. This additional step generates the spectral data needed for melanopic calculations.</p> <p>Key difference from standard workflow</p> <p>The main difference compared to standard photopic illuminance calculation is setting <code>mbsdf=True</code> when creating glazing systems. This generates additional melanopic BSDF matrices for each glazing system.</p>"},{"location":"how-to/guide_radep4/#example-1-double-glazing-system","title":"Example 1: Double glazing system","text":"<p>Create a double-pane glazing system with electrochromic glass:</p> <pre><code>gs2 = fr.create_glazing_system(\n    name=\"gs1\",\n    layer_inputs=[\n        fr.LayerInput(\"igsdb_product_7406.json\"),  # electrochromic glass\n        fr.LayerInput(\"CLEAR_3.DAT\"),  # clear glass\n    ],\n    nproc=4,\n    mbsdf=True,  # (1)\n)\n</code></pre> <ol> <li>Enable melanopic BSDF generation for both layers in the glazing system.</li> </ol>"},{"location":"how-to/guide_radep4/#add-glazing-systems-to-energyplus-model","title":"Add glazing systems to EnergyPlus model","text":"<pre><code>epmodel.add_glazing_system(gs1)\n</code></pre>"},{"location":"how-to/guide_radep4/#3-setup-energyplus-simulation-with-radiance","title":"3. Setup EnergyPlus Simulation with Radiance","text":"<p>Initialize EnergyPlus simulation setup by calling <code>EnergyPlusSetup</code> with <code>enable_radiance=True</code>. See How to enable Radiance in EnergyPlus simulation? for more information.</p> <pre><code>epsetup = fr.EnergyPlusSetup(\n    epmodel,\n    weather_files[\"usa_ca_san_francisco\"],\n    enable_radiance=True,  # (1)\n)\n</code></pre> <ol> <li>Enable Radiance for daylighting calculations. This is required for both photopic and melanopic illuminance calculations.</li> </ol>"},{"location":"how-to/guide_radep4/#4-add-melanopic-bsdf-to-the-simulation","title":"4. Add melanopic BSDF to the simulation","text":"<p>After creating the glazing systems with melanopic BSDF, you need to add them to the EnergyPlus simulation setup. This registers the melanopic BSDF data for use in calculations.</p> <p>Additional step for melanopic calculations</p> <p>This step is unique to melanopic illuminance calculations. For photopic illuminance, you do not need to call <code>add_melanopic_bsdf()</code>.</p> <pre><code>epsetup.add_melanopic_bsdf(gs1)\n</code></pre>"},{"location":"how-to/guide_radep4/#5-calculate-photopic-and-melanopic-illuminance","title":"5. Calculate photopic and melanopic illuminance","text":"<p>Now you can calculate both photopic illuminance and melanopic illuminance for a specific zone and time.</p>"},{"location":"how-to/guide_radep4/#define-calculation-parameters","title":"Define calculation parameters","text":"<pre><code>zone = \"Perimeter_bot_ZN_1\"  # zone name\nwindow = \"Perimeter_bot_ZN_1_Wall_South_Window\"  # window name\ntime = datetime(2025, 7, 31, 12, 0)  # date and time\ndni = 800  # direct normal irradiance (W/m\u00b2)\ndhi = 100  # diffuse horizontal irradiance (W/m\u00b2)\nsky_cover = 0.5  # sky cover fraction (0-1)\n</code></pre>"},{"location":"how-to/guide_radep4/#calculate-photopic-illuminance-using-calculate_sensor","title":"Calculate photopic illuminance using calculate_sensor","text":"<p>Calculate photopic illuminance:</p> <pre><code>ev = epsetup.rworkflows[zone].calculate_sensor(\n    sensor=zone,\n    bsdf={window: \"gs1\"},  # (1)\n    time=time,\n    dni=dni,\n    dhi=dhi,\n)\n</code></pre> <ol> <li>Dictionary mapping window name to glazing system name. Multiple windows can be specified.</li> </ol> <p>Tip</p> <p><code>calculate_sensor()</code> returns an array of illuminance values for each sensor point. Use <code>.mean()</code> to get the average illuminance across all sensor points.</p>"},{"location":"how-to/guide_radep4/#calculate-melanopic-illuminance-using-calculate_mev","title":"Calculate melanopic illuminance using calculate_mev","text":"<p>Calculate melanopic illuminance:</p> <pre><code>mev = epsetup.rworkflows[zone].calculate_mev(\n    sensor=zone,\n    bsdf={window: \"gs1\"},  # (1)\n    time=time,\n    dni=dni,\n    dhi=dhi,\n    sky_cover=sky_cover,  # (2)\n)\n</code></pre> <ol> <li>Dictionary mapping window name to glazing system name.</li> <li>Sky cover fraction is required for melanopic calculations to account for spectral variations in sky conditions.</li> </ol>"},{"location":"how-to/guide_radep4/#summary","title":"Summary","text":"<p>Key differences between photopic and melanopic illuminance calculations:</p> Aspect Photopic Illuminance Melanopic Illuminance Function <code>calculate_sensor()</code> <code>calculate_mev()</code> Glazing system setup <code>create_glazing_system()</code> <code>create_glazing_system(mbsdf=True)</code> Additional setup None <code>epsetup.add_melanopic_bsdf(gs)</code> Required parameters zone, window, time, dni, dhi zone, window, time, dni, dhi, sky_cover Units lux melanopic lux Purpose Visual task performance Circadian and non-visual effects <p>When to use melanopic illuminance</p> <p>Calculate melanopic illuminance when evaluating:</p> <ul> <li>Circadian lighting design</li> <li>Lighting for alertness and productivity</li> <li>Compliance with WELL Building Standard or similar</li> <li>Optimization of window shading for circadian health</li> <li>Comparison of different glazing systems for non-visual effects</li> </ul>"},{"location":"ref/config/","title":"WorkflowConfig","text":""},{"location":"ref/config/#frads.WorkflowConfig","title":"frads.WorkflowConfig  <code>dataclass</code>","text":"<pre><code>WorkflowConfig(settings, model)\n</code></pre> <p>Workflow configuration dataclass.</p> <p>Workflow configuration is initialized with the Settings and Model dataclasses. A hash string is generated from the config content.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>Settings</code> <p>A Settings object.</p> <code>model</code> <code>Model</code> <p>A Model object.</p> <code>hash_str</code> <code>str</code> <p>A hash string of the config content.</p>"},{"location":"ref/config/#frads.WorkflowConfig.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(obj)\n</code></pre> <p>Generate a WorkflowConfig object from a dictionary. Args:     obj: A dictionary of workflow configuration. Returns:     A WorkflowConfig object.</p>"},{"location":"ref/config/#frads.methods.Settings","title":"frads.methods.Settings  <code>dataclass</code>","text":"<pre><code>Settings(name='', num_processors=4, method='3phase', overwrite=False, save_matrices=False, matrix_dir='Matrices', sky_basis='r4', window_basis='kf', non_coplanar_basis='kf', sun_basis='r6', sun_culling=True, separate_direct=False, epw_file='', wea_file='', start_hour=8, end_hour=18, daylight_hours_only=True, latitude=37, longitude=122, time_zone=120, orientation=0, site_elevation=100, sensor_sky_matrix=(lambda: ['-ab', '6', '-ad', '8192', '-lw', '5e-5'])(), sensor_sun_matrix=(lambda: ['-ab', '1', '-ad', '256', '-lw', '1e-3', '-dj', '0', '-st', '0'])(), view_sun_matrix=(lambda: ['-ab', '1', '-ad', '256', '-lw', '1e-3', '-dj', '0', '-st', '0'])(), view_sky_matrix=(lambda: ['-ab', '6', '-ad', '8192', '-lw', '5e-5'])(), daylight_matrix=(lambda: ['-ab', '2', '-c', '5000'])(), sensor_window_matrix=(lambda: ['-ab', '5', '-ad', '8192', '-lw', '5e-5'])(), surface_window_matrix=(lambda: ['-ab', '5', '-ad', '8192', '-lw', '5e-5', '-c', '10000'])(), view_window_matrix=(lambda: ['-ab', '5', '-ad', '8192', '-lw', '5e-5'])(), output_directory='./')\n</code></pre> <p>Settings is a dataclass that holds the settings for a Radiance simulation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the simulation.</p> <code>num_processors</code> <code>int</code> <p>The number of processors to use for the simulation.</p> <code>method</code> <code>str</code> <p>The Radiance method to use for the simulation.</p> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing files.</p> <code>save_matrices</code> <code>bool</code> <p>Whether to save the matrices generated by the simulation.</p> <code>sky_basis</code> <code>str</code> <p>The sky basis to use for the simulation.</p> <code>window_basis</code> <code>str</code> <p>The window basis to use for the simulation.</p> <code>non_coplanar_basis</code> <code>str</code> <p>The non-coplanar basis to use for the simulation.</p> <code>sun_basis</code> <code>str</code> <p>The sun basis to use for the simulation.</p> <code>sun_culling</code> <code>bool</code> <p>Whether to cull suns.</p> <code>separate_direct</code> <code>bool</code> <p>Whether to separate direct and indirect contributions.</p> <code>epw_file</code> <code>str</code> <p>The path to the EPW file to use for the simulation.</p> <code>wea_file</code> <code>str</code> <p>The path to the WEA file to use for the simulation.</p> <code>start_hour</code> <code>float</code> <p>The start hour for the simulation.</p> <code>end_hour</code> <code>float</code> <p>The end hour for the simulation.</p> <code>daylight_hours_only</code> <code>bool</code> <p>Whether to simulate only daylight hours.</p> <code>latitude</code> <code>float</code> <p>The latitude for the simulation.</p> <code>longitude</code> <code>float</code> <p>The longitude for the simulation.</p> <code>timezone</code> <code>float</code> <p>The timezone for the simulation.</p> <code>orientation</code> <code>float</code> <p>sky rotation.</p> <code>site_elevation</code> <code>float</code> <p>The elevation for the simulation.</p> <code>sensor_sky_matrix</code> <code>list[str]</code> <p>The sky matrix sampling parameters</p> <code>view_sky_matrix</code> <code>list[str]</code> <p>View sky matrix sampling parameters</p> <code>sensor_sun_matrix</code> <code>list[str]</code> <p>Sensor sun matrix sampling parameters</p> <code>view_sun_matrix</code> <code>list[str]</code> <p>View sun matrix sampling parameters</p> <code>sensor_window_matrix</code> <code>list[str]</code> <p>Sensor window matrix sampling parameters</p> <code>view_window_matrix</code> <code>list[str]</code> <p>View window matrix sampling parameters</p> <code>daylight_matrix</code> <code>list[str]</code> <p>Daylight matrix sampling parameters</p> <code>output_directory</code> <code>str</code> <p>The directory to save the output files.</p>"},{"location":"ref/config/#frads.methods.Model","title":"frads.methods.Model  <code>dataclass</code>","text":"<pre><code>Model(materials, scene=SceneConfig(), windows=dict(), sensors=dict(), views=dict(), surfaces=dict())\n</code></pre> <p>Model dataclass.</p> <p>Attributes:</p> Name Type Description <code>scene</code> <code>SceneConfig</code> <p>SceneConfig object</p> <code>windows</code> <code>dict[str, WindowConfig]</code> <p>A dictionary of WindowConfig</p> <code>materials</code> <code>MaterialConfig</code> <p>MaterialConfig object</p> <code>sensors</code> <code>dict[str, SensorConfig]</code> <p>A dictionary of SensorConfig</p> <code>views</code> <code>dict[str, ViewConfig]</code> <p>A dictionary of ViewConfig</p>"},{"location":"ref/eplus/","title":"Core Classes","text":""},{"location":"ref/eplus/#frads.EnergyPlusSetup","title":"frads.EnergyPlusSetup","text":"<pre><code>EnergyPlusSetup(epmodel, weather_file=None, enable_radiance=False, nproc=1, initialize_radiance=True, output_directory='./')\n</code></pre> <p>EnergyPlus Simulation Setup.</p> <p>Attributes:</p> Name Type Description <code>api</code> <p>EnergyPlusAPI object</p> <code>epw</code> <p>Weather file path</p> <code>actuator_handles</code> <p>Actuator Handles</p> <code>variable_handles</code> <p>Variable handles</p> <code>construction_handles</code> <p>Construction Handles</p> <code>actuators</code> <p>List of actuators available</p> <code>model</code> <p>EnergyPlusModel object</p> <code>state</code> <p>EnergyPlusState object</p> <code>handles</code> <p>Handles object</p> <p>Class for setting up and running EnergyPlus simulations.</p> <p>Parameters:</p> Name Type Description Default <code>epmodel</code> <code>EnergyPlusModel</code> <p>EnergyPlusModel object</p> required <code>weather_file</code> <code>None | str</code> <p>Weather file path. (default: None)</p> <code>None</code> <code>enable_radiance</code> <code>bool</code> <p>If True, enable Radiance for Three-Phase Method. (default: False)</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup = EnergyPlusSetup(epmodel, weather_file=\"USA_CA_Oakland.Intl.AP.724930_TMY3.epw\")\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.actuate","title":"actuate","text":"<pre><code>actuate(component_type, name, key, value)\n</code></pre> <p>Set or update the operating value of an actuator in the EnergyPlus model.</p> <p>If actuator has not been requested previously, it will be requested. Set the actuator value to the value specified.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>str</code> <p>The actuator category, e.g. \"Weather Data\"</p> required <code>name</code> <code>str</code> <p>The name of the actuator to retrieve, e.g. \"Outdoor Dew Point\"</p> required <code>key</code> <code>str</code> <p>The instance of the variable to retrieve, e.g. \"Environment\"</p> required <code>value</code> <code>float</code> <p>The value to set the actuator to</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the actuator is not found</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.actuate(\"Weather Data\", \"Outdoor Dew Point\", \"Environment\", 10)\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.actuate_cfs_state","title":"actuate_cfs_state","text":"<pre><code>actuate_cfs_state(window, cfs_state)\n</code></pre> <p>Set construction state for a surface.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>str</code> <p>The name of the surface to set the CFS state for.</p> required <code>cfs_state</code> <code>str</code> <p>The name of the complex fenestration system (CFS) state to set the surface to.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.actuate_cfs_state(\"window1\", \"cfs1\")\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.actuate_cooling_setpoint","title":"actuate_cooling_setpoint","text":"<pre><code>actuate_cooling_setpoint(zone, value)\n</code></pre> <p>Set cooling setpoint for a zone.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>str</code> <p>The name of the zone to set the cooling setpoint for.</p> required <code>value</code> <code>float</code> <p>The value to set the cooling setpoint to.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.actuate_cooling_setpoint(\"zone1\", 24)\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.actuate_heating_setpoint","title":"actuate_heating_setpoint","text":"<pre><code>actuate_heating_setpoint(zone, value)\n</code></pre> <p>Set heating setpoint for a zone.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>str</code> <p>The name of the zone to set the heating setpoint for.</p> required <code>value</code> <code>float</code> <p>The value to set the heating setpoint to.</p> required Example <p>epsetup.actuate_cooling_setpoint(\"zone1\", 20)</p>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.actuate_lighting_power","title":"actuate_lighting_power","text":"<pre><code>actuate_lighting_power(light, value)\n</code></pre> <p>Set lighting power for a zone.</p> <p>Parameters:</p> Name Type Description Default <code>light</code> <code>str</code> <p>The name of the lighting object to set the lighting power for.</p> required <code>value</code> <code>float</code> <p>The value to set the lighting power to.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.actuate_lighting_power(\"zone1\", 1000)\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.calculate_edgps","title":"calculate_edgps","text":"<pre><code>calculate_edgps(zone, cfs_name)\n</code></pre> <p>Calculate enhanced simplified daylight glare probability in a zone.</p> <p>The view is positioned at the center of the zone by default, with direction facing the windows weighted by window area. Users can modify the view position and direction through rconfig before calling initialize_radiance().</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>str</code> <p>Name of the zone.</p> required <code>cfs_name</code> <code>dict[str, str]</code> <p>Dictionary of windows and their complex fenestration state.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Tuple of (enhanced simplified DGP, simplified DGP).</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If zone not found in model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; edgp, sdgp = epsetup.calculate_edgps(\"Zone1\", {\"window1\": \"state1\"})\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.calculate_mev","title":"calculate_mev","text":"<pre><code>calculate_mev(zone, cfs_name)\n</code></pre> <p>Calculate menalonpic illuminance.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>str</code> <p>Name of the zone.</p> required <code>cfs_name</code> <code>dict[str, str]</code> <p>Dictionary of windows and their complex fenestration state.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Menalonpic vertical illuminance.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If zone not found in model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.calculate_mev(\"Zone1\", \"CFS1\")\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.calculate_wpi","title":"calculate_wpi","text":"<pre><code>calculate_wpi(zone, cfs_name)\n</code></pre> <p>Calculate workplane illuminance in a zone.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>str</code> <p>Name of the zone.</p> required <code>cfs_name</code> <code>dict[str, str]</code> <p>Name of the complex fenestration state.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Workplane illuminance in lux.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If zone not found in model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.calculate_wpi(\"Zone1\", \"CFS1\")\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.get_cfs_state","title":"get_cfs_state","text":"<pre><code>get_cfs_state(window)\n</code></pre> <p>Return the current complex fenestration state with input window name</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>str</code> <p>name of the window</p> required <p>Returns:</p> Type Description <code>str</code> <p>name of the cfs state</p>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.get_datetime","title":"get_datetime","text":"<pre><code>get_datetime()\n</code></pre> <p>Get the current date and time from EnergyPlus Run time datatime format with iso_8601_format = yes. hour 0-23, minute 10 - 60 v23.2.0</p> <p>Returns:</p> Type Description <code>datetime</code> <p>datetime object</p>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.get_diffuse_horizontal_illuminance","title":"get_diffuse_horizontal_illuminance","text":"<pre><code>get_diffuse_horizontal_illuminance()\n</code></pre> <p>Get diffuse horizontal illuminance.</p> <p>Returns:</p> Type Description <code>float</code> <p>Diffuse horizontal illuminance in lux.</p> Example <p>epsetup.get_diffuse_horizontal_illuminance()</p>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.get_diffuse_horizontal_irradiance","title":"get_diffuse_horizontal_irradiance","text":"<pre><code>get_diffuse_horizontal_irradiance()\n</code></pre> <p>Get diffuse horizontal irradiance.</p> <p>Returns:</p> Type Description <code>float</code> <p>Diffuse horizontal irradiance in W/m2.</p> Example <p>epsetup.get_diffuse_horizontal_irradiance()</p>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.get_direct_normal_illuminance","title":"get_direct_normal_illuminance","text":"<pre><code>get_direct_normal_illuminance()\n</code></pre> <p>Get direct normal illuminance.</p> <p>Returns:</p> Type Description <code>float</code> <p>Direct normal illuminance in lux.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.get_direct_normal_illuminance()\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.get_direct_normal_irradiance","title":"get_direct_normal_irradiance","text":"<pre><code>get_direct_normal_irradiance()\n</code></pre> <p>Get direct normal irradiance.</p> <p>Returns:</p> Type Description <code>float</code> <p>Direct normal irradiance in W/m2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.get_direct_normal_irradiance()\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.get_total_sky_cover","title":"get_total_sky_cover","text":"<pre><code>get_total_sky_cover()\n</code></pre> <p>Get total sky cover.</p> <p>Returns:</p> Type Description <code>float</code> <p>Total sky cover in fraction.</p> Example <p>epsetup.get_total_sky_cover()</p>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.get_variable_value","title":"get_variable_value","text":"<pre><code>get_variable_value(name, key)\n</code></pre> <p>Get the value of a variable in the EnergyPlus model during runtime. The variable must be requested before it can be retrieved. If this method is called in a callback function, the variable will be requested automatically. So avoid having other methods called get_variable_value in the callback function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the variable to retrieve, e.g. \"Outdoor Dew Point\"</p> required <code>key</code> <code>str</code> <p>The instance of the variable to retrieve, e.g. \"Environment\"</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the variable</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found</p> <code>ValueError</code> <p>If the variable is not found</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.get_variable_value(\"Outdoor Dew Point\", \"Environment\")\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.initialize_radiance","title":"initialize_radiance","text":"<pre><code>initialize_radiance(zones=None, nproc=1)\n</code></pre> <p>Initialize Radiance for Three-Phase Method.</p> <p>Parameters:</p> Name Type Description Default <code>zones</code> <code>None | list[str]</code> <p>List of zones to initialize. If None, initialize all zones.</p> <code>None</code> <code>nproc</code> <code>int</code> <p>Number of processors to use for generating matrices.</p> <code>1</code>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.request_variable","title":"request_variable","text":"<pre><code>request_variable(name, key)\n</code></pre> <p>Request a variable from the EnergyPlus model for access during runtime.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the variable to retrieve, e.g. \"Outdoor Dew Point\"</p> required <code>key</code> <code>str</code> <p>The instance of the variable to retrieve, e.g. \"Environment\"</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.request_variable(\"Outdoor Dew Point\", \"Environment\")\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.run","title":"run","text":"<pre><code>run(output_directory='./', output_prefix='eplus', output_suffix='L', silent=False, annual=False, design_day=False)\n</code></pre> <p>Run EnergyPlus simulation.</p> <p>Parameters:</p> Name Type Description Default <code>output_directory</code> <code>None | str</code> <p>Output directory path. (default: current directory)</p> <code>'./'</code> <code>output_prefix</code> <code>None | str</code> <p>Prefix for output files. (default: eplus)</p> <code>'eplus'</code> <code>output_suffix</code> <code>None | str</code> <p>Suffix style for output files. (default: L) L: Legacy (e.g., eplustbl.csv) C: Capital (e.g., eplusTable.csv) D: Dash (e.g., eplus-table.csv)</p> <code>'L'</code> <code>silent</code> <code>bool</code> <p>If True, do not print EnergyPlus output to console. (default: False)</p> <code>False</code> <code>annual</code> <code>bool</code> <p>If True, force run annual simulation. (default: False)</p> <code>False</code> <code>design_day</code> <code>bool</code> <p>If True, force run design-day-only simulation. (default: False)</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.run(output_prefix=\"test1\", silent=True)\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusSetup.set_callback","title":"set_callback","text":"<pre><code>set_callback(method_name, func)\n</code></pre> <p>Set callback function for EnergyPlus runtime API.</p> <p>Parameters:</p> Name Type Description Default <code>method_name</code> <code>str</code> <p>Name of the method to set callback for.</p> required <code>func</code> <code>Callable</code> <p>Callback function.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If method_name is not found in EnergyPlus runtime API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; epsetup.set_callback(\"callback_begin_system_timestep_before_predictor\", func)\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusModel","title":"frads.EnergyPlusModel","text":"<p>               Bases: <code>EnergyPlusModel</code></p> <p>EnergyPlus Model object</p> <p>Attributes:</p> Name Type Description <code>walls_window</code> <p>list of walls with windows</p> <code>floors</code> <p>list of floors</p> <code>lighting_zone</code> <p>list of lighting zones</p> <code>zones</code> <p>list of zones</p>"},{"location":"ref/eplus/#frads.EnergyPlusModel.floors","title":"floors  <code>property</code>","text":"<pre><code>floors\n</code></pre> <p>Get all of the floor names.</p>"},{"location":"ref/eplus/#frads.EnergyPlusModel.window_walls","title":"window_walls  <code>property</code>","text":"<pre><code>window_walls\n</code></pre> <p>Get list of walls with windows.</p>"},{"location":"ref/eplus/#frads.EnergyPlusModel.add_glazing_system","title":"add_glazing_system","text":"<pre><code>add_glazing_system(glzsys)\n</code></pre> <p>Add glazing system to EnergyPlusModel's epjs dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>glzsys</code> <code>GlazingSystem</code> <p>GlazingSystem object</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If solar and photopic results are not computed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model = load_energyplus_model(Path(\"model.idf\"))\n&gt;&gt;&gt; model.add_glazing_system(glazing_system1)\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusModel.add_lighting","title":"add_lighting","text":"<pre><code>add_lighting(zone, lighting_level, replace=False)\n</code></pre> <p>Add lighting object to EnergyPlusModel's epjs dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>str</code> <p>Zone name to add lighting to.</p> required <code>lighting_level</code> <code>float</code> <p>Lighting level in Watts.</p> required <code>replace</code> <code>bool</code> <p>If True, replace existing lighting object in zone.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If zone not found in model.</p> <code>ValueError</code> <p>If lighting already exists in zone and replace is False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.add_lighting(\"Zone1\", 10)\n</code></pre>"},{"location":"ref/eplus/#frads.EnergyPlusModel.add_output","title":"add_output","text":"<pre><code>add_output(output_type, output_name, reporting_frequency='Timestep')\n</code></pre> <p>Add an output variable or meter to the epjs dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>output_type</code> <code>str</code> <p>Type of the output. \"variable\" or \"meter\".</p> required <code>output_name</code> <code>str</code> <p>Name of the output variable or meter.</p> required <code>reporting_frequency</code> <code>str</code> <p>Reporting frequency of the output variable or meter.</p> <code>'Timestep'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If output_type is not \"variable\" or \"meter\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.add_output(\"Zone Mean Air Temperature\", \"variable\")\n&gt;&gt;&gt; model.add_output(\"Cooling:Electricity\", \"meter\")\n</code></pre>"},{"location":"ref/eplus/#model-loading-and-conversion","title":"Model Loading and Conversion","text":""},{"location":"ref/eplus/#frads.load_energyplus_model","title":"frads.load_energyplus_model","text":"<pre><code>load_energyplus_model(fpath)\n</code></pre> <p>Load EnergyPlus model from IDF or epJSON file.</p> <p>Supports loading EnergyPlus models from both IDF (Input Data File) and epJSON (EnergyPlus JSON) formats. IDF files are automatically converted to epJSON format during loading.</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <code>str | Path</code> <p>Path to the EnergyPlus model file (.idf or .epJSON/.json).</p> required <p>Returns:</p> Type Description <code>EnergyPlusModel</code> <p>EnergyPlusModel object containing the parsed building model data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If file extension is not .idf, .epJSON, or .json.</p> <code>FileNotFoundError</code> <p>If the specified file does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Load from IDF file\n&gt;&gt;&gt; model = load_energyplus_model(\"building.idf\")\n&gt;&gt;&gt; # Load from epJSON file\n&gt;&gt;&gt; model = load_energyplus_model(\"building.epJSON\")\n&gt;&gt;&gt; print(f\"Building has {len(model.zones)} zones\")\n</code></pre>"},{"location":"ref/eplus/#frads.epmodel_to_radmodel","title":"frads.epmodel_to_radmodel","text":"<pre><code>epmodel_to_radmodel(ep_model, epw_file=None, add_views=True, views=None, output_directory='./')\n</code></pre> <p>Convert EnergyPlus model to Radiance models where each zone is a separate model.</p> <p>Parameters:</p> Name Type Description Default <code>ep_model</code> <code>EnergyPlusModel</code> <p>EnergyPlus model.</p> required <code>epw_file</code> <code>None | str</code> <p>EnergyPlus weather file path. Defaults to None.</p> <code>None</code> <code>add_views</code> <code>bool</code> <p>Add views to the model. Such views will be positioned at the center of the zone facing windows weighted by window area. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Radiance models.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; radmodels = epmodel_to_radmodel(ep_model, epw_file)\n</code></pre>"},{"location":"ref/eplus/#utility-functions","title":"Utility Functions","text":""},{"location":"ref/eplus/#frads.ep_datetime_parser","title":"frads.ep_datetime_parser","text":"<pre><code>ep_datetime_parser(inp)\n</code></pre> <p>Parse date and time from EnergyPlus output format.</p> <p>EnergyPlus outputs dates and times in \"MM/DD HH:MM:SS\" format. This function handles the special case where EnergyPlus uses \"24:00:00\" to represent midnight of the next day.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Date and time string from EnergyPlus output (e.g., \"01/15 14:30:00\").</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>A datetime object representing the parsed date and time.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ep_datetime_parser(\"01/15 14:30:00\")\ndatetime.datetime(1900, 1, 15, 14, 30)\n&gt;&gt;&gt; ep_datetime_parser(\"12/31 24:00:00\")  # Midnight of next day\ndatetime.datetime(1901, 1, 1, 0, 0)\n</code></pre>"},{"location":"ref/fivephase/","title":"FivePhaseMethod","text":""},{"location":"ref/fivephase/#frads.FivePhaseMethod","title":"frads.FivePhaseMethod","text":"<pre><code>FivePhaseMethod(config)\n</code></pre> <p>               Bases: <code>PhaseMethod</code></p> <p>A class representing the Five-Phase Method, which is an extension of the three-phase method, allowing for more complex simulations. It includes various matrices, octrees, and other attributes used in the simulation.</p> <p>Attributes:</p> Name Type Description <code>blacked_out_octree</code> <code>Path</code> <p>Path to the octree with blacked-out surfaces.</p> <code>vmap_oct</code> <code>Path</code> <p>Path to the vmap octree.</p> <code>cdmap_oct</code> <code>Path</code> <p>Path to the cdmap octree.</p> <code>window_senders</code> <code>dict[str, SurfaceSender]</code> <p>dictionary of window sender objects.</p> <code>window_receivers</code> <code>dict[str, SurfaceReceiver]</code> <p>dictionary of window receiver objects.</p> <code>window_bsdfs</code> <code>dict[str, ndarray]</code> <p>dictionary of window BSDFs.</p> <code>view_window_matrices</code> <code>dict[str, Matrix]</code> <p>dictionary of view window matrices.</p> <code>sensor_window_matrices</code> <code>dict[str, Matrix]</code> <p>dictionary of sensor window matrices.</p> <code>daylight_matrices</code> <code>dict[str, Matrix]</code> <p>dictionary of daylight matrices.</p> <code>direct_sun_matrix</code> <code>ndarray</code> <p>Direct sun matrix.</p> <p>Initializes the FivePhaseMethod object by setting up octrees, matrices, and other necessary attributes.</p> <p>Reads materials and scene files, constructs necessary octrees, and prepares window objects, sun receivers, and various mapping matrices based on the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>WorkflowConfig</code> <p>WorkflowConfig object containing all necessary information for initializing the five-phase method.</p> required"},{"location":"ref/fivephase/#frads.FivePhaseMethod.load_matrices","title":"load_matrices","text":"<pre><code>load_matrices()\n</code></pre>"},{"location":"ref/matrix/","title":"matrix","text":"<p>Frads Matrix class simply encapsulate the components necessary to generate a matrix, such as ray sender and  receiver. The matrix data is by default store as numpy  array in memory for later access.</p>"},{"location":"ref/matrix/#frads.Matrix","title":"frads.Matrix","text":"<pre><code>Matrix(sender, receivers, octree=None, surfaces=None)\n</code></pre> <p>General matrix object for daylight and view factor calculations.</p> <p>This class represents a transfer matrix between senders and receivers, encoding how light travels from source points/surfaces to destination points/surfaces. Used for daylight simulations, view factor calculations, and lighting analysis.</p> <p>Attributes:</p> Name Type Description <code>sender</code> <p>Sender object (sensors, view, or surface) that emits light.</p> <code>receivers</code> <p>List of receiver objects that collect light.</p> <code>array</code> <p>Numpy array or list of arrays storing the matrix data with shape (nrows, ncols, ncomp) where ncomp is typically 3 for RGB.</p> <code>ncols</code> <p>Number of columns (receiver basis size) or list of sizes for multiple receivers.</p> <code>nrows</code> <code>int</code> <p>Number of rows (sender basis size or sensor count).</p> <code>dtype</code> <p>Matrix data type ('d' for double, 'f' for float).</p> <code>ncomp</code> <p>Number of color components (typically 3 for RGB).</p> <code>octree</code> <p>Path to octree file used for ray tracing acceleration.</p> <code>surfaces</code> <p>List of environment surface primitives for the scene.</p> <p>Initialize a matrix object.</p> <p>Parameters:</p> Name Type Description Default <code>sender</code> <code>SensorSender | ViewSender | SurfaceSender</code> <p>Sender object (SensorSender, ViewSender, or SurfaceSender).</p> required <code>receivers</code> <code>list[SkyReceiver] | list[SurfaceReceiver] | list[SunReceiver]</code> <p>List of receiver objects (SurfaceReceiver, SkyReceiver, or SunReceiver). Multiple receivers are only supported for SurfaceReceiver types.</p> required <code>octree</code> <code>None | str</code> <p>Optional path to octree file for ray tracing.</p> <code>None</code> <code>surfaces</code> <code>None | list[Primitive]</code> <p>Optional list of environment surface primitives for the scene.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If sender/receiver types are invalid or incompatible.</p>"},{"location":"ref/matrix/#frads.Matrix.generate","title":"generate","text":"<pre><code>generate(params, nproc=1, sparse=False, to_file=False, memmap=False)\n</code></pre> <p>Generate the matrix using Radiance rfluxmtx tool.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>list[str]</code> <p>List of rfluxmtx command-line parameters (e.g., ['-ab', '3', '-ad', '1000']).</p> required <code>nproc</code> <code>int</code> <p>Number of parallel processes to use for calculation.</p> <code>1</code> <code>sparse</code> <code>bool</code> <p>If True, convert result to sparse matrix format for memory efficiency.</p> <code>False</code> <code>to_file</code> <code>bool</code> <p>If True, write matrix directly to file without storing in memory. Useful for very large matrices that exceed available RAM.</p> <code>False</code> <code>memmap</code> <code>bool</code> <p>If True, use memory mapping to store matrix data on disk. Allows handling of matrices larger than available RAM.</p> <code>False</code>"},{"location":"ref/matrix/#frads.SensorSender","title":"frads.SensorSender","text":"<pre><code>SensorSender(sensors, ray_count=1)\n</code></pre> <p>Sender object representing a collection of point sensors.</p> <p>This class creates a sender object from a list of point sensors, where each sensor is defined by position and direction vectors. Used for illuminance calculations at specific points in space.</p> <p>Attributes:</p> Name Type Description <code>sensors</code> <p>List of sensors, each containing 6 float values [x, y, z, dx, dy, dz] representing position (x,y,z) and direction (dx,dy,dz) vectors.</p> <code>content</code> <p>Sensor data encoded as bytes for Radiance input.</p> <code>yres</code> <p>Number of unique sensor locations (before ray multiplication).</p> <p>Initialize a sensor sender object.</p> <p>Parameters:</p> Name Type Description Default <code>sensors</code> <code>list[list[float]]</code> <p>List of sensors, each containing 6 float values [x, y, z, dx, dy, dz] representing position and direction vectors.</p> required <code>ray_count</code> <code>int</code> <p>Number of rays to generate per sensor for Monte Carlo sampling. Higher values improve accuracy but increase computation time.</p> <code>1</code>"},{"location":"ref/matrix/#frads.ViewSender","title":"frads.ViewSender","text":"<pre><code>ViewSender(view, ray_count=1, xres=800, yres=800)\n</code></pre> <p>Sender object representing a camera view for luminance calculations.</p> <p>This class creates a sender object from a camera view definition, generating rays for each pixel in the view. Used for creating luminance images and view-based daylight analysis.</p> <p>Attributes:</p> Name Type Description <code>view</code> <p>Pyradiance View object defining camera parameters (position, direction, etc.).</p> <code>content</code> <p>View rays encoded as bytes for Radiance input.</p> <code>xres</code> <p>Horizontal resolution (number of pixels in x-direction).</p> <code>yres</code> <p>Vertical resolution (number of pixels in y-direction).</p> <p>Initialize a view sender object.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>View</code> <p>Pyradiance View object defining camera parameters.</p> required <code>ray_count</code> <code>int</code> <p>Number of rays per pixel for anti-aliasing and Monte Carlo sampling.</p> <code>1</code> <code>xres</code> <code>int</code> <p>Horizontal resolution in pixels.</p> <code>800</code> <code>yres</code> <code>int</code> <p>Vertical resolution in pixels.</p> <code>800</code>"},{"location":"ref/matrix/#frads.SurfaceSender","title":"frads.SurfaceSender","text":"<pre><code>SurfaceSender(surfaces, basis, left_hand=False, offset=None)\n</code></pre> <p>Sender object representing surfaces with directional sampling.</p> <p>This class creates a sender object from surface primitives using a specified sampling basis. Used for calculating inter-surface view factors and daylight transmission through surfaces like windows.</p> <p>Attributes:</p> Name Type Description <code>surfaces</code> <p>List of surface primitives (polygons or rings) to use as senders.</p> <code>basis</code> <p>Sampling basis string (e.g., 'kf', 'r4', 'sc6') defining directional discretization for the surface.</p> <code>content</code> <p>Surface data encoded as string for Radiance rfluxmtx input.</p> <p>Initialize a surface sender object.</p> <p>Parameters:</p> Name Type Description Default <code>surfaces</code> <code>list[Primitive]</code> <p>List of surface primitives (polygons or rings) to use as senders.</p> required <code>basis</code> <code>str</code> <p>Sampling basis string defining directional discretization (e.g., 'kf' for Klems full, 'r4' for Reinhart 4-division).</p> required <code>left_hand</code> <code>bool</code> <p>Whether to use left-hand coordinate system for basis orientation.</p> <code>False</code> <code>offset</code> <code>float | None</code> <p>Distance to offset the sender surface along its normal vector. Useful for avoiding self-intersection in calculations.</p> <code>None</code>"},{"location":"ref/matrix/#frads.SkyReceiver","title":"frads.SkyReceiver","text":"<pre><code>SkyReceiver(basis, out=None)\n</code></pre> <p>               Bases: <code>Receiver</code></p> <p>Receiver object representing the sky dome for daylight calculations.</p> <p>This class creates a receiver object that represents the entire sky dome, including both sky and ground hemispheres. Used in daylight matrix calculations to capture contributions from all sky directions.</p> <p>Attributes:</p> Name Type Description <code>basis</code> <p>Sampling basis string defining sky patch discretization.</p> <code>content</code> <p>Sky dome definition encoded as string for Radiance input.</p> <p>Initialize a sky receiver object.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>str</code> <p>Sampling basis string defining sky patch discretization (e.g., 'kf' for Klems full, 'r4' for Reinhart 4-division).</p> required <code>out</code> <code>str | None</code> <p>Optional output file path for matrix results.</p> <code>None</code>"},{"location":"ref/matrix/#frads.SurfaceReceiver","title":"frads.SurfaceReceiver","text":"<pre><code>SurfaceReceiver(surfaces, basis, left_hand=False, offset=None, source='glow', out=None)\n</code></pre> <p>               Bases: <code>Receiver</code></p> <p>Receiver object representing surfaces that collect light.</p> <p>This class creates a receiver object from surface primitives using a specified sampling basis. Used for calculating how much light surfaces receive from various sources in daylight and artificial lighting simulations.</p> <p>Attributes:</p> Name Type Description <code>surfaces</code> <p>List of surface primitives (polygons or rings) acting as receivers.</p> <code>basis</code> <p>Sampling basis string defining directional discretization.</p> <code>content</code> <p>Surface data encoded as string for Radiance rfluxmtx input.</p> <p>Initialize a surface receiver object.</p> <p>Parameters:</p> Name Type Description Default <code>surfaces</code> <code>list[Primitive]</code> <p>List of surface primitives (polygons or rings) to use as receivers.</p> required <code>basis</code> <code>str</code> <p>Sampling basis string defining directional discretization.</p> required <code>left_hand</code> <code>bool</code> <p>Whether to use left-hand coordinate system for basis orientation.</p> <code>False</code> <code>offset</code> <code>float | None</code> <p>Distance to offset the receiver surface along its normal vector.</p> <code>None</code> <code>source</code> <code>str</code> <p>Light source type for the receiver ('glow' or 'light').</p> <code>'glow'</code> <code>out</code> <code>str | None</code> <p>Optional output file path for matrix results.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If surfaces are not primitives or contain invalid types.</p>"},{"location":"ref/matrix/#frads.SunMatrix","title":"frads.SunMatrix","text":"<pre><code>SunMatrix(sender, receiver, octree, surfaces=None)\n</code></pre> <p>               Bases: <code>Matrix</code></p> <p>Specialized matrix object for direct solar radiation calculations.</p> <p>This class extends the base Matrix class to handle sun-only calculations using the Radiance rcontrib tool. It's optimized for sparse matrices since most solar positions contribute zero radiation at any given time.</p> <p>Attributes:</p> Name Type Description <code>sender</code> <p>Sender object (SensorSender or ViewSender only).</p> <code>receiver</code> <p>SunReceiver object representing discrete solar positions.</p> <code>octree</code> <p>Path to octree file for ray tracing acceleration.</p> <code>surfaces</code> <p>List of environment surface file paths.</p> <code>array</code> <p>Sparse matrix array storing sun contribution data.</p> <code>nrows</code> <code>int</code> <p>Number of rows (sender basis size or sensor count).</p> <code>ncols</code> <p>Number of columns (solar position count).</p> <code>dtype</code> <p>Matrix data type ('d' for double, 'f' for float).</p> <code>ncomp</code> <p>Number of color components (typically 3 for RGB).</p> <p>Initialize a sun matrix object.</p> <p>Parameters:</p> Name Type Description Default <code>sender</code> <code>SensorSender | ViewSender</code> <p>Sender object (SensorSender or ViewSender only).</p> required <code>receiver</code> <code>SunReceiver</code> <p>SunReceiver object representing discrete solar positions.</p> required <code>octree</code> <code>str | None</code> <p>Optional path to octree file for ray tracing acceleration.</p> required <code>surfaces</code> <code>list[str] | None</code> <p>Optional list of environment surface file paths.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If sender is a SurfaceSender (not supported for sun matrices).</p>"},{"location":"ref/matrix/#frads.SunMatrix.generate","title":"generate","text":"<pre><code>generate(parameters, nproc=1, radmtx=False, sparse=False)\n</code></pre> <p>Generate the sun matrix using Radiance rcontrib tool.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>list[str]</code> <p>List of rcontrib command-line parameters (e.g., ['-ab', '1', '-ad', '512']).</p> required <code>nproc</code> <code>int</code> <p>Number of parallel processes to use for calculation.</p> <code>1</code> <code>radmtx</code> <code>bool</code> <p>If True, return raw matrix bytes instead of processing into numpy array.</p> <code>False</code> <code>sparse</code> <code>bool</code> <p>If True, store result as sparse matrix format (recommended for sun matrices due to their inherently sparse nature).</p> <code>False</code> <p>Returns:</p> Type Description <code>None | bytes</code> <p>Raw matrix bytes if radmtx=True, otherwise None (matrix stored in self.array).</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If receiver is not a SunReceiver object.</p>"},{"location":"ref/matrix/#frads.SunReceiver","title":"frads.SunReceiver","text":"<pre><code>SunReceiver(basis, sun_matrix=None, window_normals=None, full_mod=False)\n</code></pre> <p>               Bases: <code>Receiver</code></p> <p>Receiver object representing discrete solar positions for direct sun calculations.</p> <p>This class creates a receiver object that represents the sun at discrete positions based on a Reinhart-Tregenza sky division. The number of active sun positions can be reduced based on annual solar data or window visibility constraints.</p> <p>Attributes:</p> Name Type Description <code>basis</code> <p>Sampling basis string (must be Reinhart-Tregenza format like 'r4').</p> <code>content</code> <p>Sun positions encoded as Radiance light sources.</p> <code>modifiers</code> <p>List of sun modifier names for active solar positions.</p> <p>Initialize a sun receiver object.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>str</code> <p>Sampling basis string (must be Reinhart-Tregenza format like 'r4').</p> required <code>sun_matrix</code> <code>None | ndarray</code> <p>Optional annual sun matrix to filter out zero-contribution solar positions. Shape should be (time_steps, sun_positions, components).</p> <code>None</code> <code>window_normals</code> <code>None | list[ndarray]</code> <p>Optional list of window normal vectors to filter out sun positions not visible through windows.</p> <code>None</code> <code>full_mod</code> <code>bool</code> <p>If True, include all sun modifiers regardless of filtering. If False, only include modifiers for active sun positions.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If basis is not a valid Reinhart-Tregenza format.</p>"},{"location":"ref/matrix/#frads.load_matrix","title":"frads.load_matrix","text":"<pre><code>load_matrix(file, dtype='float')\n</code></pre> <p>Load a Radiance matrix file into a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>bytes | str | Path</code> <p>Path to Radiance matrix file or raw matrix bytes.</p> required <code>dtype</code> <code>str</code> <p>Data type for the output array ('float' or 'double').</p> <code>'float'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Numpy array with shape (nrows, ncols, ncomp) containing the matrix data.</p>"},{"location":"ref/matrix/#frads.load_binary_matrix","title":"frads.load_binary_matrix","text":"<pre><code>load_binary_matrix(buffer, nrows, ncols, ncomp, dtype, header=False)\n</code></pre> <p>Load a binary matrix buffer into a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>bytes</code> <p>Raw binary data containing the matrix.</p> required <code>nrows</code> <code>int</code> <p>Number of matrix rows.</p> required <code>ncols</code> <code>int</code> <p>Number of matrix columns.</p> required <code>ncomp</code> <code>int</code> <p>Number of color components (typically 3 for RGB).</p> required <code>dtype</code> <code>str</code> <p>Data type string ('d' for double, 'f' for float).</p> required <code>header</code> <code>bool</code> <p>If True, strip Radiance header from buffer before parsing.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Numpy array with shape (nrows, ncols, ncomp) containing the matrix data.</p>"},{"location":"ref/matrix/#frads.surfaces_view_factor","title":"frads.surfaces_view_factor","text":"<pre><code>surfaces_view_factor(surfaces, env, ray_count=10000)\n</code></pre> <p>Calculate surface-to-surface view factors using rfluxmtx.</p> <p>Computes geometric view factors between surfaces, representing the fraction of radiation leaving one surface that directly reaches another surface.</p> <p>Parameters:</p> Name Type Description Default <code>surfaces</code> <code>list[Primitive]</code> <p>List of surface primitives to calculate view factors for. Surface normals must face outward (away from the surface).</p> required <code>env</code> <code>list[Primitive]</code> <p>List of environment surface primitives that surfaces are exposed to. Surface normals must face inward (toward the calculation domain).</p> required <code>ray_count</code> <code>int</code> <p>Number of rays to spawn from each surface for Monte Carlo integration. Higher values improve accuracy but increase computation time.</p> <code>10000</code> <p>Returns:</p> Type Description <code>dict[str, dict[str, list[float]]]</code> <p>Nested dictionary where outer keys are source surface identifiers and</p> <code>dict[str, dict[str, list[float]]]</code> <p>inner keys are target surface identifiers, with values being RGB view factors.</p>"},{"location":"ref/sky/","title":"Weather Data Classes","text":""},{"location":"ref/sky/#frads.WeaMetaData","title":"frads.WeaMetaData","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Weather related meta data object.</p> <p>Attributes:</p> Name Type Description <code>city</code> <code>str</code> <p>City.</p> <code>country</code> <code>str</code> <p>Country.</p> <code>latitude</code> <code>float</code> <p>Latitude.</p> <code>longitude</code> <code>float</code> <p>Longitude.</p> <code>timezone</code> <code>int</code> <p>Timezone as standard meridian.</p> <code>elevation</code> <code>float</code> <p>Site elevation (m).</p>"},{"location":"ref/sky/#frads.WeaMetaData.wea_header","title":"wea_header","text":"<pre><code>wea_header()\n</code></pre> <p>Return a .wea format header.</p>"},{"location":"ref/sky/#frads.WeaData","title":"frads.WeaData","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Weather related data object.</p> <p>Attributes:</p> Name Type Description <code>month</code> <p>Month.</p> <code>day</code> <p>Day.</p> <code>hour</code> <p>Hour.</p> <code>minute</code> <p>Minutes.</p> <code>second</code> <p>Seconds.</p> <code>hours</code> <p>Times with minutes as fraction.</p> <code>dni</code> <code>float</code> <p>Direct normal irradiance (W/m2) or illuminance (lux).</p> <code>dhi</code> <code>float</code> <p>Diffuse horizontal irradiance (W/m2) or illuminance (lux).</p> <code>aod</code> <code>float</code> <p>Aeroal Optical Depth (default = 0).</p> <code>cc</code> <code>float</code> <p>Cloud cover (default = 0).</p> <code>year</code> <code>float</code> <p>default = 2000.</p>"},{"location":"ref/sky/#weather-file-parsing","title":"Weather File Parsing","text":""},{"location":"ref/sky/#frads.parse_epw","title":"frads.parse_epw","text":"<pre><code>parse_epw(epw_str)\n</code></pre> <p>Parse epw file and return wea header and data.</p> <p>Parameters:</p> Name Type Description Default <code>epw_str</code> <code>str</code> <p>String containing epw file.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of meta data and wea data.</p>"},{"location":"ref/sky/#frads.parse_wea","title":"frads.parse_wea","text":"<pre><code>parse_wea(wea_str)\n</code></pre> <p>Parse a WEA weather file.</p> <p>Parameters:</p> Name Type Description Default <code>wea_str</code> <code>str</code> <p>String containing the complete WEA file content.</p> required <p>Returns:</p> Type Description <code>tuple[WeaMetaData, list[WeaData]]</code> <p>A tuple containing: - WeaMetaData: Location and site information - list[WeaData]: List of weather data entries for each time step</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open('weather.wea', 'r') as f:\n...     content = f.read()\n&gt;&gt;&gt; metadata, data = parse_wea(content)\n&gt;&gt;&gt; print(f\"Location: {metadata.city}\")\n&gt;&gt;&gt; print(f\"Data points: {len(data)}\")\n</code></pre>"},{"location":"ref/sky/#sky-generation","title":"Sky Generation","text":""},{"location":"ref/sky/#frads.gen_perez_sky","title":"frads.gen_perez_sky","text":"<pre><code>gen_perez_sky(dt, latitude, longitude, timezone, year=None, dirnorm=None, diffhor=None, dirhor=None, dirnorm_illum=None, diffhor_illum=None, solar=False, grefl=None, rotate=None)\n</code></pre> <p>Generate a Perez sky model using the gendaylit Radiance command.</p> <p>Creates a realistic sky luminance distribution based on the Perez all-weather sky model, which accounts for varying sky conditions from clear to overcast.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>Date and time for the sky calculation.</p> required <code>latitude</code> <code>float</code> <p>Site latitude in degrees (positive North, negative South).</p> required <code>longitude</code> <code>float</code> <p>Site longitude in degrees (positive East, negative West).</p> required <code>timezone</code> <code>int</code> <p>Standard meridian for timezone in degrees.</p> required <code>year</code> <code>None | int</code> <p>Year for the calculation (optional, uses dt.year if None).</p> <code>None</code> <code>dirnorm</code> <code>None | float</code> <p>Direct normal irradiance in W/m\u00b2 (optional).</p> <code>None</code> <code>diffhor</code> <code>None | float</code> <p>Diffuse horizontal irradiance in W/m\u00b2 (optional).</p> <code>None</code> <code>dirhor</code> <code>None | float</code> <p>Direct horizontal irradiance in W/m\u00b2 (optional).</p> <code>None</code> <code>dirnorm_illum</code> <code>None | float</code> <p>Direct normal illuminance in lux (optional).</p> <code>None</code> <code>diffhor_illum</code> <code>None | float</code> <p>Diffuse horizontal illuminance in lux (optional).</p> <code>None</code> <code>solar</code> <code>bool</code> <p>If True, include solar disk in the sky model.</p> <code>False</code> <code>grefl</code> <code>None | float</code> <p>Ground reflectance (0.0-1.0, default varies by season).</p> <code>None</code> <code>rotate</code> <code>None | float</code> <p>Sky rotation angle in degrees (optional).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>the sky primitive.</p>"},{"location":"ref/sky/#frads.genskymtx","title":"frads.genskymtx","text":"<pre><code>genskymtx(data=None, meta=None, wpath=None, onesun=False, header=True, average=False, sun_only=False, sky_only=False, sun_file=None, sun_mods=None, daylight_hours_only=False, sky_color=None, ground_color=None, rotate=None, outform=None, solar_radiance=False, mfactor=1)\n</code></pre> <p>Call gendaymtx to generate a sky/sun matrix Write results to out.  It takes either a .wea file path or wea data and metadata (defined in frads.types). If both are provided, .wea file path will be used.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>None | Sequence[WeaData]</code> <p>A list of WeaData objects.</p> <code>None</code> <code>meta</code> <code>None | WeaMetaData</code> <p>A WeaMetaData object.</p> <code>None</code> <code>wpath</code> <code>None | str | Path</code> <p>A .wea file path.</p> <code>None</code> <code>onesun</code> <code>bool</code> <p>If True, only one sun will be generated.</p> <code>False</code> <code>header</code> <code>bool</code> <p>If True, a header will be included in the output.</p> <code>True</code> <code>average</code> <code>bool</code> <p>If True, the output will be averaged.</p> <code>False</code> <code>sun_only</code> <code>bool</code> <p>If True, only sun will be generated.</p> <code>False</code> <code>sky_only</code> <code>bool</code> <p>If True, only sky will be generated.</p> <code>False</code> <code>sun_file</code> <code>None | str</code> <p>A sun file path.</p> <code>None</code> <code>sun_mods</code> <code>None | str</code> <p>A sun modifier.</p> <code>None</code> <code>daylight_hours_only</code> <code>bool</code> <p>If True, only daylight hours will be generated.</p> <code>False</code> <code>sky_color</code> <code>None | list[float]</code> <p>A list of sky color values.</p> <code>None</code> <code>ground_color</code> <code>None | list[float]</code> <p>A list of ground color values.</p> <code>None</code> <code>rotate</code> <code>None | float</code> <p>A rotation value.</p> <code>None</code> <code>outform</code> <code>None | str</code> <p>An output format.</p> <code>None</code> <code>solar_radiance</code> <code>bool</code> <p>If True, solar radiance will be generated.</p> <code>False</code> <code>mfactor</code> <code>int</code> <p>An mfactor value.</p> <code>1</code> <p>Returns:</p> Type Description <code>bytes</code> <p>A bytes object containing the output.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>An error occurs if neither a .wea path nor wea data is provided.</p>"},{"location":"ref/threephase/","title":"ThreePhaseMethod","text":""},{"location":"ref/threephase/#frads.ThreePhaseMethod","title":"frads.ThreePhaseMethod","text":"<pre><code>ThreePhaseMethod(config)\n</code></pre> <p>               Bases: <code>PhaseMethod</code></p> <p>Three phase method implementation.</p> <p>Attributes:</p> Name Type Description <code>config</code> <p>A WorkflowConfig object</p> <code>octree</code> <p>A path to the octree file</p> <code>window_senders</code> <code>dict[str, SurfaceSender]</code> <p>A dictionary of window sender matrices</p> <code>window_receivers</code> <p>A dictionary of window receiver matrices</p> <code>window_bsdfs</code> <p>A dictionary of window BSDF matrices</p> <code>daylight_matrices</code> <p>A dictionary of daylight matrices</p> <code>view_window_matrices</code> <p>A dictionary of view window matrices</p> <code>sensor_window_matrices</code> <p>A dictionary of sensor window matrices</p>"},{"location":"ref/threephase/#frads.ThreePhaseMethod.calculate_edgps","title":"calculate_edgps","text":"<pre><code>calculate_edgps(view, bsdf, time, dni, dhi, ambient_bounce=0, save_hdr=None)\n</code></pre> <p>Calculate enhanced simplified daylight glare probability (EDGPs) for a view.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>str</code> <p>view name, must be in config.model.views</p> required <code>bsdf</code> <code>dict[str, str]</code> <p>a dictionary of window name as key and bsdf matrix or matrix name as value</p> required <code>time</code> <code>datetime</code> <p>datetime object</p> required <code>dni</code> <code>float</code> <p>direct normal irradiance</p> required <code>dhi</code> <code>float</code> <p>diffuse horizontal irradiance</p> required <code>ambient_bounce</code> <code>int</code> <p>ambient bounce, default to 1. Could be set to zero for macroscopic non-scattering systems.</p> <code>0</code> <p>Returns:     EDGPs</p>"},{"location":"ref/threephase/#frads.ThreePhaseMethod.calculate_mev","title":"calculate_mev","text":"<pre><code>calculate_mev(sensor, bsdf, time, dni, dhi, sky_cover)\n</code></pre> <p>Calculate menalonpic vertical illuminance.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>sensor name, must be in config.model.sensors</p> required <code>bsdf</code> <code>dict[str, str]</code> <p>a dictionary of window name as key and bsdf matrix or matrix name as value</p> required <code>time</code> <code>datetime</code> <p>datetime object</p> required <code>dni</code> <code>float</code> <p>direct normal irradiance</p> required <code>dhi</code> <code>float</code> <p>diffuse horizontal irradiance</p> required <code>sky_cover</code> <code>float</code> <p>sky cover fraction</p> required <p>Returns:     Menalonpic vertical illuminance</p>"},{"location":"ref/threephase/#frads.ThreePhaseMethod.calculate_sensor","title":"calculate_sensor","text":"<pre><code>calculate_sensor(sensor, bsdf, time, dni, dhi)\n</code></pre> <p>Calculate illuminance for a sensor.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>The sensor name</p> required <code>bsdf</code> <code>dict[str, str]</code> <p>A dictionary of window name as key and bsdf matrix or matrix name as value</p> required <code>time</code> <code>datetime</code> <p>The datetime object</p> required <code>dni</code> <code>float</code> <p>The direct normal irradiance</p> required <code>dhi</code> <code>float</code> <p>The diffuse horizontal irradiance</p> required <p>Returns:     A float value of illuminance</p>"},{"location":"ref/threephase/#frads.ThreePhaseMethod.calculate_sensor_from_wea","title":"calculate_sensor_from_wea","text":"<pre><code>calculate_sensor_from_wea(sensor)\n</code></pre> <p>Calculates the sensor values from wea data.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>The specific sensor for which the calculation is to be performed.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: A matrix containing the calculated sensor values based on the Weather Attribute data, sensor configuration, and various matrices related to windows, daylight, and sky.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no wea data is available.</p> <p>Examples:</p> <p>sensor_values = sensor_config.calculate_sensor_from_wea(\"sensor_name\")</p>"},{"location":"ref/threephase/#frads.ThreePhaseMethod.calculate_view","title":"calculate_view","text":"<pre><code>calculate_view(view, bsdf, time, dni, dhi)\n</code></pre> <p>Calculate (render) a view.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>str</code> <p>The view name</p> required <code>bsdf</code> <code>ndarray</code> <p>The BSDF matrix</p> required <code>time</code> <code>datetime</code> <p>The datetime object</p> required <code>dni</code> <code>float</code> <p>The direct normal irradiance</p> required <code>dhi</code> <code>float</code> <p>The diffuse horizontal irradiance</p> required <p>Returns:     A image as numpy array</p>"},{"location":"ref/threephase/#frads.ThreePhaseMethod.calculate_view_from_wea","title":"calculate_view_from_wea","text":"<pre><code>calculate_view_from_wea(view)\n</code></pre> <p>Calculate(render) view from wea data.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>str</code> <p>The view name</p> required <p>Returns:     A series of HDR images as a numpy array</p>"},{"location":"ref/threephase/#frads.ThreePhaseMethod.generate_matrices","title":"generate_matrices","text":"<pre><code>generate_matrices(view_matrices=True)\n</code></pre> <p>Generate all required matrices</p> <p>Parameters:</p> Name Type Description Default <code>view_matrices</code> <code>bool</code> <p>Toggle to generate view matrices. Toggle it off can be useful for not needing the view matrices but still need the view data for things like edgps calculation.</p> <code>True</code>"},{"location":"ref/threephase/#frads.ThreePhaseMethod.load_matrices","title":"load_matrices","text":"<pre><code>load_matrices()\n</code></pre> <p>Load matrices from a .npz file in the Matrices directory.</p>"},{"location":"ref/threephase/#frads.ThreePhaseMethod.save_matrices","title":"save_matrices","text":"<pre><code>save_matrices()\n</code></pre> <p>Saves the view window matrices, sensor window matrices, and daylight matrices to a NumPy <code>.npz</code> file.</p> <p>The matrices are saved with keys formed by concatenating the corresponding view, sensor, or window name with '_window_matrix' or '_daylight_matrix'.</p>"},{"location":"ref/twophase/","title":"TwoPhaseMethod","text":""},{"location":"ref/twophase/#frads.TwoPhaseMethod","title":"frads.TwoPhaseMethod","text":"<pre><code>TwoPhaseMethod(config)\n</code></pre> <p>               Bases: <code>PhaseMethod</code></p> <p>Implements two phase method.</p> <p>Initializes the two phase method</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>WorkflowConfig</code> <p>A WorkflowConfig object</p> required"},{"location":"ref/twophase/#frads.TwoPhaseMethod.calculate_sensor","title":"calculate_sensor","text":"<pre><code>calculate_sensor(sensor, time, dni, dhi)\n</code></pre> <p>Calculate a sensor view.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>A sensor name, must be loaded during configuration.</p> required <code>time</code> <code>datetime</code> <p>A datetime object</p> required <code>dni</code> <code>float</code> <p>Direct normal irradiance</p> required <code>dhi</code> <code>float</code> <p>Diffuse horizontal irradiance</p> required <p>Returns:     Sensor illuminance value</p>"},{"location":"ref/twophase/#frads.TwoPhaseMethod.calculate_sensor_from_wea","title":"calculate_sensor_from_wea","text":"<pre><code>calculate_sensor_from_wea(sensor)\n</code></pre> <p>Calculate a sensor for tue duration of the weather file that's loaded during configuration.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>str</code> <p>sensor name, must be loaded during configuration.</p> required <p>Returns:     A numpy array containing a series of illuminance values</p>"},{"location":"ref/twophase/#frads.TwoPhaseMethod.calculate_view","title":"calculate_view","text":"<pre><code>calculate_view(view, time, dni, dhi)\n</code></pre> <p>Calculate (render) a view. Args:     view: A view name, must bed loaded during configuration.     time: A datetime object     dni: Direct normal irradiance     dhi: Diffuse horizontal irradiance Returns:     A image as a numpy array</p>"},{"location":"ref/twophase/#frads.TwoPhaseMethod.calculate_view_from_wea","title":"calculate_view_from_wea","text":"<pre><code>calculate_view_from_wea(view)\n</code></pre> <p>Render a series of images for a view. Rendering using the weather file loaded during configuration.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>str</code> <p>View name, must be loaded during configuration.</p> required <p>Returns:     A numpy array containing a series of images</p>"},{"location":"ref/twophase/#frads.TwoPhaseMethod.generate_matrices","title":"generate_matrices","text":"<pre><code>generate_matrices()\n</code></pre> <p>Generate matrices for all view and sensor points.</p>"},{"location":"ref/twophase/#frads.TwoPhaseMethod.load_matrices","title":"load_matrices","text":"<pre><code>load_matrices()\n</code></pre> <p>Load matrices from a .npz file</p>"},{"location":"ref/twophase/#frads.TwoPhaseMethod.save_matrices","title":"save_matrices","text":"<pre><code>save_matrices()\n</code></pre> <p>Save matrices to a .npz file in the Matrices directory. File name is the hash string of the configuration.</p>"},{"location":"ref/window/","title":"Core Classes","text":""},{"location":"ref/window/#frads.GlazingSystem","title":"frads.GlazingSystem  <code>dataclass</code>","text":"<pre><code>GlazingSystem(name, thickness=0, layers=list(), gaps=list(), visible_front_transmittance=list(), visible_back_transmittance=list(), visible_front_reflectance=list(), visible_back_reflectance=list(), solar_front_transmittance=list(), solar_back_transmittance=list(), solar_front_reflectance=list(), solar_back_reflectance=list(), solar_front_absorptance=list(), solar_back_absorptance=list(), melanopic_back_transmittance=list(), melanopic_back_reflectance=list())\n</code></pre> <p>Glazing system data object.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the glazing system.</p> <code>thickness</code> <code>float</code> <p>Thickness of the glazing system.</p> <code>layers</code> <code>list[Layer]</code> <p>List of Layer objects.</p> <code>gaps</code> <code>list[Gap]</code> <p>List of Gap objects.</p> <code>visible_front_transmittance</code> <code>list[list[float]]</code> <p>Visible front transmittance matrix.</p> <code>visible_back_transmittance</code> <code>list[list[float]]</code> <p>Visible back transmittance matrix.</p> <code>visible_front_reflectance</code> <code>list[list[float]]</code> <p>Visible front reflectance matrix.</p> <code>visible_back_reflectance</code> <code>list[list[float]]</code> <p>Visible back reflectance matrix.</p> <code>solar_front_transmittance</code> <code>list[list[float]]</code> <p>Solar front transmittance matrix.</p> <code>solar_back_transmittance</code> <code>list[list[float]]</code> <p>Solar back transmittance matrix.</p> <code>solar_front_reflectance</code> <code>list[list[float]]</code> <p>Solar front reflectance matrix.</p> <code>solar_back_reflectance</code> <code>list[list[float]]</code> <p>Solar back reflectance matrix.</p> <code>solar_front_absorptance</code> <code>list[list[float]]</code> <p>Solar front absorptance matrix by layer.</p> <code>solar_back_absorptance</code> <code>list[list[float]]</code> <p>Solar back absorptance matrix by layer.</p>"},{"location":"ref/window/#frads.GlazingSystem.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(path)\n</code></pre> <p>Load a glazing system from a JSON file.</p>"},{"location":"ref/window/#frads.GlazingSystem.get_brtdfunc","title":"get_brtdfunc","text":"<pre><code>get_brtdfunc(name=None)\n</code></pre> <p>Get a BRTDfunc primitive for the glazing system.</p>"},{"location":"ref/window/#frads.GlazingSystem.save","title":"save","text":"<pre><code>save(out)\n</code></pre> <p>Save the glazing system to a file.</p>"},{"location":"ref/window/#frads.GlazingSystem.to_xml","title":"to_xml","text":"<pre><code>to_xml(out)\n</code></pre> <p>Save the glazing system to a file.</p>"},{"location":"ref/window/#frads.Gap","title":"frads.Gap  <code>dataclass</code>","text":"<pre><code>Gap(gas, thickness_m)\n</code></pre> <p>Gap data object.</p> <p>Attributes:</p> Name Type Description <code>gas</code> <code>list[Gas]</code> <p>List of Gas objects.</p> <code>thickness</code> <code>list[Gas]</code> <p>Thickness of the gap.</p>"},{"location":"ref/window/#frads.Gas","title":"frads.Gas  <code>dataclass</code>","text":"<pre><code>Gas(gas, ratio)\n</code></pre> <p>Gas data object.</p> <p>Attributes:</p> Name Type Description <code>gas</code> <code>str</code> <p>Gas type.</p> <code>ratio</code> <code>float</code> <p>Gas ratio.</p>"},{"location":"ref/window/#frads.LayerInput","title":"frads.LayerInput  <code>dataclass</code>","text":"<pre><code>LayerInput(input_source, flipped=False, slat_angle_deg=0.0, openings=OpeningDefinitions())\n</code></pre>"},{"location":"ref/window/#glazing-system-functions","title":"Glazing System Functions","text":""},{"location":"ref/window/#frads.create_glazing_system","title":"frads.create_glazing_system","text":"<pre><code>create_glazing_system(name, layer_inputs, gaps=None, nproc=1, nsamp=2000, mbsdf=False)\n</code></pre> <p>Create a glazing system from a list of layers and gaps.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the glazing system.</p> required <code>layer_inputs</code> <code>list[LayerInput]</code> <p>List of layer inputs containing material specifications.</p> required <code>gaps</code> <code>None | list[Gap]</code> <p>List of gaps between layers (auto-generated if None).</p> <code>None</code> <code>nproc</code> <code>int</code> <p>Number of processes for parallel computation.</p> <code>1</code> <code>nsamp</code> <code>int</code> <p>Number of samples for Monte Carlo integration.</p> <code>2000</code> <code>mbsdf</code> <code>bool</code> <p>Whether to generate melanopic BSDF data.</p> <code>False</code> <p>Returns:</p> Type Description <code>GlazingSystem</code> <p>GlazingSystem object containing optical and thermal properties.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid layer type or input format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from frads import LayerInput\n&gt;&gt;&gt; layers = [\n...     LayerInput(\"glass.json\"),\n...     LayerInput(\"venetian.xml\")\n... ]\n&gt;&gt;&gt; gs = create_glazing_system(\"double_glazed\", layers)\n</code></pre>"}]}